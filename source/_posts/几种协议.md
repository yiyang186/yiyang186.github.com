---
title: 几种网络协议
date: 2016-05-16 22:49:00
categories:
  - 网络
tags: 
  - H3C
  - ARP
  - IP
  - RIP
  - OSPF
---

# ARP协议
## 概念
ARP, Address Resolution Protocol，地址解析协议
地址解析：物理网络使用的是硬件地址进行报文传输，IP地址不能被物理网络所识别。所以必须建立两种地址的映射关系，这个过程称为地址解析。ARP是动态协议，即地址解析这个过程是自动完成的。
ARP缓存：每台使用ARP的主机，保留了一个专用内存区(缓存),存放最近的IP地址与硬件地址的对应关系。

## ARP解析过程
### 同一网段的ARP解析过程
若PCA的ARP缓存中找不PCB的MAC地址，就广播ARP请求报文，其他主机忽略这个请求，只要IP地址是PCB的主机才会回应，将它自己的硬件地址写入应答报文后直接发给PCA。PCA收到后将其写入缓存。
### 不同网段的ARP解析过程
如PCB与PCA不再同一网段（根据PCB的IP地址和PCA自己的子网掩码），PCA想向PCB发报文，需要经过默认网关，解析过程转换为解析同一网段的默认网关mac地址的过程。默认网关得到报文后再另一个网络中去重复ARP地址解析过程。在这里，PCA并不需要知道PCB的MAC地址，它只需要知道默认网关的MAC地址就行了，给其他网段的报文统统交给默认网关去处理。

## 指令
在cmd中通过命令"arp -a"查看ARP缓存，"arp -d"清空ARP缓存

# PPP协议

## 概念
PPP（Point to Point Protocol）即点对点协议,是一种广域网链路层协议，可以帮助隔了很多个异构网络的两端实现逻辑直连。我们常用的宽带拨号就是PPPoE协议(Point to Point Protocol over Ethernet)，即以太网上的点对点协议。PPP有身份认证的功能，当运营商确认了我们的身份后才会给我们分配IP地址，我们才可以上网。
### 组成部分
1. 一个将IP数据报封装到串行链路的方法。
2. 一个用来建立、配置和测试数据链路链接的链路控制协议LCP(Link Control Protocol)，用于通信双方协商选项
3. 一套网络控制协议(NCP，Network Control Protocol)，支持不同的网络层协议

## 两种验证方式
### PAP
**特点**：验证从客户端发起，密码明文传输，仅在连接建立阶段进行，数据传输阶段不进行PAP验证.
**过程**: 
1. A与B间通过PPP协议互联，A设置为验证方，B为被验证方，当B拨通A后，B会将用户名（一般设置为路由器的名字）与口令一起发给A；
2. 验证方A根据本端的数据库查看是否有此用户，口令是否正确。如正确则会给对端发送ACK报文，通告对端已被允许进入下一阶段协商；否则发送NAK报文，通告对端验证失败。
### CHAP
略

## 配置
我们学校通过串口连接两个路由器，做这个实验需要进入Serial 0/0配置
```
[R1]inter Serial 0/0
[R1-Serial0/0]ip address 192.0.0.1 24
[R1-Serial0/0]link-protocol ppp # 启动PPP
[R1-Serial0/0]shutdown
[R1-Serial0/0]undo shutdown # 需要重启端口才会生效
# R2也需要进行类似配置,并测试是否能ping通
<R1>debugging ppp all
<R1>terminal debugging
[R1-Serial0/0]shutdown
[R1-Serial0/0]undo shutdown
```
### LCP状态转移图
根据R1的debug信息画出LCP状态转移图
![这里写图片描述](http://img.blog.csdn.net/20160516173207816)

### PAP验证状态转移图
这里用R1为主验证方，来验证R2，用户名RTB, 密码aaa
```
[R1]local-uer RTB class network # 配置用户列表
[R1-user-RTB]service-type ppp # 配置服务类型
[R1-user-RTB]password simple aaa # 这是该用户密码
[R1-user-RTB]quit
[R1]inter Serial 0/0
[R1-Serial0/0]ppp authentication pap # 为s0/0端口授权PAP验证
# 重启端口，生效配置
[R1-Serial0/0]shutdown
[R1-Serial0/0]undo shutdown
```
重启端口，不是路由器。还要在R2添加R1的用户名和密码
```
[R2]inter Serial 0/0
# 在该端口添加用户名和密码
[R2-Serial0/0]ppp pap local-user RTB password simple aaa
# 重启端口，生效配置
[R1-Serial0/0]shutdown
[R1-Serial0/0]undo shutdown
```
执行下列指令显示debug信息，画出PAP状态转移图
```
验证R1是否能ping通R2
<R1>debugging ppp all
<R1>terminal debugging
[R1-Serial0/0]shutdown
[R1-Serial0/0]undo shutdown
```

# IP协议

## 概念
这里不介绍报文格式了，直接上图，记住报头至少20个字节就好了。
![这里写图片描述](http://img.blog.csdn.net/20160516203037693)
这是一份封装了ICMP报文的IP报文，下面灰色的字节是IP的报头，报头后的字节是数据部分

报文在网络中的传输主要分为
1. 主机发送：直接交付和间接交付。通过对目的地址和子网掩码相与来判断目的主机是否和自己在同一网络，如在同一网络则直接交付，若不在同以网络将报文交给路由器(默认网关)间接交付，至于路由器怎么交付，我主机不care.
2. 路由器转发：将目的地址和路由器各端口的子网掩码相与，若目的主机在与路由器直接相连的网络中则直接交付。否则，查找本路由器的路由表，转发给路由表指示的下一跳路由器。路由表中每一行都要“目的网络地址，子网掩码，下一跳地址”,按最长匹配原则索引目的网络地址。如果没有匹配的就转发给默认路由。至于下一跳路由怎么做，本路由不care.

**路由**
控制报文进行转发的路径信息，存储路由信息的表格称为路由表，路由表如何生产？有静态配置(手动设置)和动态生成两种方法。

**路由表，ARP表，MAC表**：
路由表根据目的网络（目的）索引下一跳地址， ARP缓存(ARP表)根据IP地址索引MAC地址，MAC地址表根据MAC地址索引发送端口。这一套使用下来，路由器就知道该从哪个端口发送数据了。

**独臂路由**
独臂路由解决的是不同VLAN 间的通信问题，它是用一个物理接口来划分出多个逻辑子接口来当做物理接口来用，这样可以节约真正的物理接口。VLAN之间的数据传输先要进入路由器处理，然后输出，以使得网络中的大部分报文在同一个VLAN内的传输将用不着通过路由器而直接在交换设备间进行高速传输。

## 配置静态路由
```
# 参数为目的IP，子网掩码，下一跳地址
[R1]ip route-static 192.168.10.10 24 192.168.2.1 
# 配置缺省路由（缺省路由是静态的）
[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.2.1 
```

# RIP协议
## 概念
**动态路由**（dynamic route ）

- 路由表项是路由协议动态生成
- 根据网络结构或流量的变化，路由协议会自动调整路由信息以实现路由。

**动态路由协议**

- 按网络范围划分
内部网关协议－RIP，OSPF，IS-IS
外部网关协议－EGP，BGP
- 按寻径算法划分
距离矢量协议－RIP，BGP
链路状态协议－OSPF，IS-IS

**RIP协议**
RIP协议是一种动态路由协议，按网络范围划分是一种内部网关协议（IGP），用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（Distance Vector Algorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。

## RIP协议原理
RIP路由协议的设计比较简单，在相邻的路由器之间周期性地交换整个路由表，并应用距离矢量算法来计算路由。
![这里写图片描述](http://img.blog.csdn.net/20160517103941967)

1. 初始时刻，每台路由器上只有自身的直连路由，当启动RIP协议后，在第一个30秒内，所有路由器会向邻居路由器发送自己的完整的路由表。
![这里写图片描述](http://img.blog.csdn.net/20160517104029428)

2. 这时，路由器A和C收到了路由器B的路由表，路由器B则收到了路由器A和C的路由表，通过与自身的路由表进行比较，计算路由的跳数并更新路由表。这时路由器B已经有了全部网段的路由，而A和C分别缺4网段和1网段的路由。需要通过下一个时间周期的路由信息交换来获得。
![这里写图片描述](http://img.blog.csdn.net/20160517104525851)

3. 由于路由器B已经获得了A和C的路由信息，因此在第二个30秒，路由器A可以从B那里获得C的信息，同样C也可以从B那里获得A的信息，这样ABC都获得了全部网段的路由信息。
![这里写图片描述](http://img.blog.csdn.net/20160517104806167)

## 路由环路问题
1. RIP协议在设计中没有考虑路由环路的问题，使得它存在重大缺陷。例如，当整个路由信息交换完成后，如果突然与路由器A相连的1网段链路发生故障，其S1接口为down状态，该路由项将被删除，如果此时路由器A还没有到向其他路由器通告它的路由表的时间，却收到了来自路由器B的路由通告。
![这里写图片描述](http://img.blog.csdn.net/20160517104959513)

2. 这时，路由器A会认为到1网段还有另外一条途径，它无法判断这条路由信息实际上是之前它发送给路由器B的。路由器A更新1网段路由信息，与下一跳路由器相连的接口改为S0，跳数为2.随后，路由器A会将其新的路由表通告给相邻路由器B，因为路由器B中的1网段路由是从路由器A学习的，因此路由器B会更新1网段的路由，将跳数加1.这样，路由器A、B、C的1网段的路由的跳数会不断的增加下去，直到溢出。而此时，如果有目的IP地址是1网段的报文被路由器C转发到路由器B，路由器B会将该报文转发给路由器A，而路由器A又会将此报文转发回路由器B，如此往复，直至报文的TTL字段值为0后，报文被丢弃。报文路由器A和B之间循环转圈就称为路由环路。它会很快的消耗掉连接A、B路由器的链路的带宽，对网络的危害很大。
![这里写图片描述](http://img.blog.csdn.net/20160517105257751)

3. 针对这种情况，RIP协议进行了很多的改进，例如：定义最大路由权值、触发更新、毒性逆转。但是，都没能够从根本上解决问题，使得RIP协议的使用受到了很大的限制。而究其主要原因，路由信息中没有携带始发通告路由器是主要原因。
![这里写图片描述](http://img.blog.csdn.net/20160517105351136)

# OSPF协议

## 概念
Open Shortest Path First，开放最短路由优先协议一个基于链路状态（Link status）的内部网关协议。
**核心思想**
每一台路由器将其周边的链路状态(接口直连网段、相连的路由器等信息)描述出来，发送给网络中相邻的路由器。经过一段时间的链路状态信息交互，每台路由器都保存了一个链路状态数据库，该数据库是整个网络完整的链路状态描述，最后在此基础上应用Shortest Path First算法计算路由(最短路径)。

**AS自治系统**
使用同一组选路策略的路由器的集合，OSPF就应用在AS内部，除了OSPF协议还可以使用RIP, IS-IS协议，自治系统间可以使用BGP协议。

**区域**
OSPF将一个AS分成多个区域，一个区域有着相同的拓扑结构数据库。区域ID用一个32BIT的整数来标示，可以用IP地址格式表示也可以用一个十进制整数表示。

**Router ID**
OSPF协议使用Router ID唯一表示一台路由器，采用IP地址的形式表示，可认为指定，也可能是路由器的回环地址或者最大的地址。

## OSPF报文
如下图所示，OSPF协议直接用IP报文来封装自己的协议报文，其中LSA(Link Status Advertisement)为链路状态通告，路由器将把自己的链路状态以LSA报文的形式封装，作为OSPF的数据部分，与邻近的路由器分享自己的链路拓扑。
![这里写图片描述](http://img.blog.csdn.net/20160517093123045)

上图中的OSPF报头的格式如下
![这里写图片描述](http://img.blog.csdn.net/20160517093404604)
上图第2个字段“type”指出该OSPF报文的类型，数值从1到5分别是下列5种类型

### OSPF协议报文的5种类型
- Hello报文: 发现及维持邻居关系，选举DR(指定路由器)，BDR(备份指定路由器)。
- DD报文: 本地LSDB的摘要
- LSR报文: 向对端请求本端没有或对端的更新的LSA
- LSU报文: 向对方发送其需要的LSA
- LSAck报文: 收到LSU之后，进行确认

下图为一段DD报文，与上面的报文格式对照会理解的清楚一些
![这里写图片描述](http://img.blog.csdn.net/20160517094959183)


## OSPF协议的邻居状态机
OSPF协议获取网络拓扑结构的过程是自动的，它从开始到最后获得邻居所有的链路信息(建立邻接状态)需要经过许多过程，OSPF的邻居状态机显示了在这个协商过程中路由器状态的变化。

- Down： 邻居状态机的初始状态，是指在过去的Dead-Interval时间内没有收到对方的Hello报文 
- Attempt： 只适用于NBMA类型的接口，处于本状态时，定期向那些手工配置的邻居发送HELLO报文 
- Init ： 本状态表示已经收到了邻居的HELLO报文，但是该报文中列出的邻居中没有包含本Router ID（对方并没有收到我发的HELLO报文） 
- 2-Way ：本状态表示双方互相收到了对端发送的HELLO报文，建立了邻居关系。在广播和NBMA类型的网络中，两个接口状态是DROther的路由器之间将停留在此状态。其他情况状态机将继续转入高级状态。
- ExStart ： 在此状态下，路由器和它的邻居之间通过互相交换DD报文（该报文并不包含实际的内容，只包含一些标志位）来决定发送时的主/从关系。建立主/从关系主要是为了保证在后续的DD报文交换中能够有序的发送。 
- Exchange ： 路由器将本地的LSDB用DD报文来描述，并发给邻居 
- Loading ： 路由器发送LSR报文向邻居请求对方的LSU报文 
- Full ： 在此状态下，邻居路由器的LSDB中所有的LSA本路由器全都有了。本路由器和邻居建立了邻接状态 

![这里写图片描述](http://img.blog.csdn.net/20160517095403049)

### OSPF报文交互过程
两台路由器的交互过程及其状态变化如下：
![这里写图片描述](http://img.blog.csdn.net/20160517100455336)
注意上图中，路由器交互过程的第2，3步DD报文主从关系协商和交换摘要信息中的seq, I，M, MS字段在DD报文(OSPF报文中的一种类型)中的字段位置如下：
![这里写图片描述](http://img.blog.csdn.net/20160517101946175)

## OSPF配置
```
[R1]router id 1.1.1.1 # 为该路由器配置Router ID
[R1]ospf 	# 启动OSPF进程
[R1]area 0 	# 创建区域0,并进入区域0视图
# 指定在1.1.1.0网段上应用OSPF0.0.0.255是反掩码
[R1-ospf-1-area-0.0.0.0]network 1.1.1.0 0.0.0.255
```