<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Try try try Never mind">
<meta property="og:type" content="website">
<meta property="og:title" content="Yiyang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Yiyang&#39;s Blog">
<meta property="og:description" content="Try try try Never mind">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yiyang&#39;s Blog">
<meta name="twitter:description" content="Try try try Never mind">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Yiyang's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3b9de7582df94dad7be13b2e75675386";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yiyang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/06/怎样用scipy求一些统计量的p值和分位数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/06/怎样用scipy求一些统计量的p值和分位数/" itemprop="url">怎样用scipy求一些统计量的p值和分位数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-06T11:05:00+08:00">
                2016-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>scipy.stats模块中有不少涉及计算统计量的子模块<br>如<br>scipy.stats.uniform<br>scipy.stats.norm<br>scipy.stats.t<br>scipy.stats.chi2<br>scipy.stats.f<br>更多子模块参见<a href="http://docs.scipy.org/doc/scipy/reference/stats.html" target="_blank" rel="external">这里</a></p>
<p>其中scipy.stats.f内有如下方法：<br><img src="http://img.blog.csdn.net/20161006104131553" alt="图一"><br>来自于<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f.html#scipy.stats.f" target="_blank" rel="external">这里</a></p>
<p>这些方法在其他子模块中都大同小异。这里重点介绍求F统计量的p值和分位数，t统计量，卡方，正态，的求法基本类似。</p>
<p>例1：求$Pr(F_{4,58}>1.67)=?$,即已知临界值求p值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from scipy.stats import f</div><div class="line">&gt;&gt;&gt; f.sf(1.67, 4, 58)</div><div class="line">0.16927935111708425</div><div class="line">&gt;&gt;&gt; 1 - f.cdf(1.67, 4, 58)</div><div class="line">0.16927935111708448</div></pre></td></tr></table></figure></p>
<p>例2：求$F_{4,58}^{(1-0.17)}=?$ ,即已知p值求临界值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from scipy.stats import f</div><div class="line">&gt;&gt;&gt; f.isf(0.17, 4, 58)</div><div class="line">1.666945416681088</div><div class="line">&gt;&gt;&gt; f.ppf(1 - 0.17, 4, 58)</div><div class="line">1.666945416681088</div></pre></td></tr></table></figure></p>
<p>其中，isf是sf的逆运算， ppf是cdf的逆运算。具体解释参见上图。其他统计量的相关计算方法与之类似，不同之处就是少了自由度作为参数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/28/centos安装caret包失败/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/28/centos安装caret包失败/" itemprop="url">centos安装caret包失败</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-28T10:02:00+08:00">
                2016-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>实验室的redhat用的是centos源，跟centos情况应该差不多。</p>
<p>当我安装caret时，R提示我以下这些包安装失败<br> ‘car’‘nloptr’, ‘lme4’, ‘pbkrtest’‘minqa’</p>
<p>理清依赖关系，最根源的问题是minqa和nloptr安装失败。</p>
<h1 id="安装minqa"><a href="#安装minqa" class="headerlink" title="安装minqa"></a>安装minqa</h1><p>安装minqa失败的原因是ld找不到libgfortran.so, 由于我已经安装了gcc, 应该有libgfortran.so的。后来我在/usr/lib64/下边找到了libgfortran.so.3.0.0（你也可能会在/usr/lib或者/usr/local/lib、/usr/local/lib64里找到）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -sv /usr/lib64/libgfortran.so.3.0.0 /usr/lib64/libgfortran.so</div></pre></td></tr></table></figure></p>
<p>然后再到R里安装minqa就行了。</p>
<h1 id="安装nloptr"><a href="#安装nloptr" class="headerlink" title="安装nloptr"></a>安装nloptr</h1><p>在stack overflow里搜到的办法是, 系统需要安装nlopt和nlopt-devel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nlopt nlopt-devel</div></pre></td></tr></table></figure></p>
<p>回到R就可以安装nloptr了</p>
<h1 id="安装caret包"><a href="#安装caret包" class="headerlink" title="安装caret包"></a>安装caret包</h1><p>接下来安装caret包就很顺利了，要是不顺利的话，再把上述依赖包一个一个安装，看看是什么问题，一个一个解决。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/08/python解压rar文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/08/python解压rar文件/" itemprop="url">python解压rar文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-08T11:49:00+08:00">
                2016-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>在数据预处理阶段，有时候会发现我们的数据存储在大量杂乱无章的压缩文件中，这些压缩文件还可能处在复杂的目录树结构下。这时候你可能会想写个python脚本来处理。<br>对于zip文件，python 的zipfile模块提供了很好的支持，但是对于rar格式的压缩文件，要麻烦一点。</p>
<h1 id="安装unrar"><a href="#安装unrar" class="headerlink" title="安装unrar"></a>安装unrar</h1><p><a href="https://pypi.python.org/pypi/unrar/" target="_blank" rel="external">unrar</a>是python下支持解压rar文件的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install unrar</div></pre></td></tr></table></figure></p>
<p>不过这个插件需要rarlib的支持，不然无法解压</p>
<h1 id="安装rarlib"><a href="#安装rarlib" class="headerlink" title="安装rarlib"></a>安装rarlib</h1><p>到<a href="http://www.rarlab.com/rar_add.htm" target="_blank" rel="external">这个网页</a>去下载相应版本的rarlib，由于我用的是windows系统，所以下载了UnRAR.dll。<br>我照着unrar文档中的方式设置UnRAR.dll的环境变量，结果毫无效果，看看报错，摸索出来了一个方法。<br>将安装好后的rarlib目录加入环境变量path（由于我的是64bit系统，所以只加入了rarlib目录下的64子目录）。由于unrar模块要搜索名为unrar.dll的文件，所以需要把目录中的UnRAR.dll， UnRAR.lib（UnRAR64.dll, UnRAR64.lib）改为unrar.dll，unrar.lib<br>这样unrar就可以顺利解压rar文件了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/27/sqlcmd简单指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/27/sqlcmd简单指令/" itemprop="url">sqlcmd简单指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-27T13:51:00+08:00">
                2016-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul>
<li>sql server 2008</li>
<li>注意1433端口是否打开[^1]</li>
</ul>
<h1 id="登陆数据库"><a href="#登陆数据库" class="headerlink" title="登陆数据库"></a>登陆数据库</h1><p>sqlcmd -S 数据库服务器地址 -U 用户名 -P 密码<br>或<br>sqlcmd -S 数据库服务器地址\数据库实例名 -U 用户名 -P 密码</p>
<h1 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h1><ol>
<li><p>查看有哪些数据库<br>>1 SELECT name FROM sys.databases<br>>2 GO<br>每次输入sql语句都要打一行go, 下面不再赘述，sys.databases是系统默认的全局变量（学过sql, 但没专门学过sql server，姑且这么叫吧）</p>
</li>
<li><p>切换数据库上下文<br>USE 数据库名</p>
</li>
<li><p>查看数据库里有哪些表<br>SELECT name FROM sysobjects</p>
</li>
<li><p>查看表中的列名<br>SELECT name FROM syscolumns WHERE id=object_id(‘表名’)</p>
</li>
<li><p>其他<br>sql server用的sql语句叫做Transact-SQL（T-SQL）, 跟sql还有点不一样，具体请参见<a href="http://imdbt.blog.51cto.com/903896/218590" target="_blank" rel="external">T-SQL经典语句</a>，以及<a href="https://msdn.microsoft.com/zh-cn/library/ms177563(v=sql.100" target="_blank" rel="external">官方文档</a>.aspx)。</p>
</li>
</ol>
<h1 id="从CSV文件导入数据库"><a href="#从CSV文件导入数据库" class="headerlink" title="从CSV文件导入数据库"></a>从CSV文件导入数据库</h1><p>先为要导入的数据建表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名( </div><div class="line">	列<span class="number">1</span> <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>), </div><div class="line">	列<span class="number">2</span> <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>), </div><div class="line">	列<span class="number">3</span> <span class="keyword">NVARCHAR</span>(<span class="keyword">MAX</span>) </div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>从csv文件中导入数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BULK <span class="keyword">INSERT</span> 表名</div><div class="line"><span class="keyword">FROM</span> <span class="string">'csv文件路径名'</span></div><div class="line"><span class="keyword">WITH</span>(</div><div class="line">	FIELDTERMINATOR = <span class="string">','</span>,</div><div class="line">	ROWTERMINATOR = <span class="string">'\n'</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>[^1]: 到sql server configuration manager里的network configuration里去设置tcp/ip的端口（IP Address选项卡拉到最下面）为1433，再重启sql server services即可，具体步骤请参见<a href="http://www.cnblogs.com/skynothing/archive/2010/08/26/1809125.html" target="_blank" rel="external">解决sqlserver 2008 sqlcmd无法登陆</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/16/几种协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/16/几种协议/" itemprop="url">几种网络协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-16T22:49:00+08:00">
                2016-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ARP, Address Resolution Protocol，地址解析协议<br>地址解析：物理网络使用的是硬件地址进行报文传输，IP地址不能被物理网络所识别。所以必须建立两种地址的映射关系，这个过程称为地址解析。ARP是动态协议，即地址解析这个过程是自动完成的。<br>ARP缓存：每台使用ARP的主机，保留了一个专用内存区(缓存),存放最近的IP地址与硬件地址的对应关系。</p>
<h2 id="ARP解析过程"><a href="#ARP解析过程" class="headerlink" title="ARP解析过程"></a>ARP解析过程</h2><h3 id="同一网段的ARP解析过程"><a href="#同一网段的ARP解析过程" class="headerlink" title="同一网段的ARP解析过程"></a>同一网段的ARP解析过程</h3><p>若PCA的ARP缓存中找不PCB的MAC地址，就广播ARP请求报文，其他主机忽略这个请求，只要IP地址是PCB的主机才会回应，将它自己的硬件地址写入应答报文后直接发给PCA。PCA收到后将其写入缓存。</p>
<h3 id="不同网段的ARP解析过程"><a href="#不同网段的ARP解析过程" class="headerlink" title="不同网段的ARP解析过程"></a>不同网段的ARP解析过程</h3><p>如PCB与PCA不再同一网段（根据PCB的IP地址和PCA自己的子网掩码），PCA想向PCB发报文，需要经过默认网关，解析过程转换为解析同一网段的默认网关mac地址的过程。默认网关得到报文后再另一个网络中去重复ARP地址解析过程。在这里，PCA并不需要知道PCB的MAC地址，它只需要知道默认网关的MAC地址就行了，给其他网段的报文统统交给默认网关去处理。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>在cmd中通过命令”arp -a”查看ARP缓存，”arp -d”清空ARP缓存</p>
<h1 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>PPP（Point to Point Protocol）即点对点协议,是一种广域网链路层协议，可以帮助隔了很多个异构网络的两端实现逻辑直连。我们常用的宽带拨号就是PPPoE协议(Point to Point Protocol over Ethernet)，即以太网上的点对点协议。PPP有身份认证的功能，当运营商确认了我们的身份后才会给我们分配IP地址，我们才可以上网。</p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>一个将IP数据报封装到串行链路的方法。</li>
<li>一个用来建立、配置和测试数据链路链接的链路控制协议LCP(Link Control Protocol)，用于通信双方协商选项</li>
<li>一套网络控制协议(NCP，Network Control Protocol)，支持不同的网络层协议</li>
</ol>
<h2 id="两种验证方式"><a href="#两种验证方式" class="headerlink" title="两种验证方式"></a>两种验证方式</h2><h3 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h3><p><strong>特点</strong>：验证从客户端发起，密码明文传输，仅在连接建立阶段进行，数据传输阶段不进行PAP验证.<br><strong>过程</strong>: </p>
<ol>
<li>A与B间通过PPP协议互联，A设置为验证方，B为被验证方，当B拨通A后，B会将用户名（一般设置为路由器的名字）与口令一起发给A；</li>
<li>验证方A根据本端的数据库查看是否有此用户，口令是否正确。如正确则会给对端发送ACK报文，通告对端已被允许进入下一阶段协商；否则发送NAK报文，通告对端验证失败。<h3 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h3>略</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们学校通过串口连接两个路由器，做这个实验需要进入Serial 0/0配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[R1]inter Serial 0/0</div><div class="line">[R1-Serial0/0]ip address 192.0.0.1 24</div><div class="line">[R1-Serial0/0]link-protocol ppp # 启动PPP</div><div class="line">[R1-Serial0/0]shutdown</div><div class="line">[R1-Serial0/0]undo shutdown # 需要重启端口才会生效</div><div class="line"># R2也需要进行类似配置,并测试是否能ping通</div><div class="line">&lt;R1&gt;debugging ppp all</div><div class="line">&lt;R1&gt;terminal debugging</div><div class="line">[R1-Serial0/0]shutdown</div><div class="line">[R1-Serial0/0]undo shutdown</div></pre></td></tr></table></figure></p>
<h3 id="LCP状态转移图"><a href="#LCP状态转移图" class="headerlink" title="LCP状态转移图"></a>LCP状态转移图</h3><p>根据R1的debug信息画出LCP状态转移图<br><img src="http://img.blog.csdn.net/20160516173207816" alt="这里写图片描述"></p>
<h3 id="PAP验证状态转移图"><a href="#PAP验证状态转移图" class="headerlink" title="PAP验证状态转移图"></a>PAP验证状态转移图</h3><p>这里用R1为主验证方，来验证R2，用户名RTB, 密码aaa<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[R1]local-uer RTB class network # 配置用户列表</div><div class="line">[R1-user-RTB]service-type ppp # 配置服务类型</div><div class="line">[R1-user-RTB]password simple aaa # 这是该用户密码</div><div class="line">[R1-user-RTB]quit</div><div class="line">[R1]inter Serial 0/0</div><div class="line">[R1-Serial0/0]ppp authentication pap # 为s0/0端口授权PAP验证</div><div class="line"># 重启端口，生效配置</div><div class="line">[R1-Serial0/0]shutdown</div><div class="line">[R1-Serial0/0]undo shutdown</div></pre></td></tr></table></figure></p>
<p>重启端口，不是路由器。还要在R2添加R1的用户名和密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[R2]inter Serial 0/0</div><div class="line"># 在该端口添加用户名和密码</div><div class="line">[R2-Serial0/0]ppp pap local-user RTB password simple aaa</div><div class="line"># 重启端口，生效配置</div><div class="line">[R1-Serial0/0]shutdown</div><div class="line">[R1-Serial0/0]undo shutdown</div></pre></td></tr></table></figure></p>
<p>执行下列指令显示debug信息，画出PAP状态转移图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">验证R1是否能ping通R2</div><div class="line">&lt;R1&gt;debugging ppp all</div><div class="line">&lt;R1&gt;terminal debugging</div><div class="line">[R1-Serial0/0]shutdown</div><div class="line">[R1-Serial0/0]undo shutdown</div></pre></td></tr></table></figure></p>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>这里不介绍报文格式了，直接上图，记住报头至少20个字节就好了。<br><img src="http://img.blog.csdn.net/20160516203037693" alt="这里写图片描述"><br>这是一份封装了ICMP报文的IP报文，下面灰色的字节是IP的报头，报头后的字节是数据部分</p>
<p>报文在网络中的传输主要分为</p>
<ol>
<li>主机发送：直接交付和间接交付。通过对目的地址和子网掩码相与来判断目的主机是否和自己在同一网络，如在同一网络则直接交付，若不在同以网络将报文交给路由器(默认网关)间接交付，至于路由器怎么交付，我主机不care.</li>
<li>路由器转发：将目的地址和路由器各端口的子网掩码相与，若目的主机在与路由器直接相连的网络中则直接交付。否则，查找本路由器的路由表，转发给路由表指示的下一跳路由器。路由表中每一行都要“目的网络地址，子网掩码，下一跳地址”,按最长匹配原则索引目的网络地址。如果没有匹配的就转发给默认路由。至于下一跳路由怎么做，本路由不care.</li>
</ol>
<p><strong>路由</strong><br>控制报文进行转发的路径信息，存储路由信息的表格称为路由表，路由表如何生产？有静态配置(手动设置)和动态生成两种方法。</p>
<p><strong>路由表，ARP表，MAC表</strong>：<br>路由表根据目的网络（目的）索引下一跳地址， ARP缓存(ARP表)根据IP地址索引MAC地址，MAC地址表根据MAC地址索引发送端口。这一套使用下来，路由器就知道该从哪个端口发送数据了。</p>
<p><strong>独臂路由</strong><br>独臂路由解决的是不同VLAN 间的通信问题，它是用一个物理接口来划分出多个逻辑子接口来当做物理接口来用，这样可以节约真正的物理接口。VLAN之间的数据传输先要进入路由器处理，然后输出，以使得网络中的大部分报文在同一个VLAN内的传输将用不着通过路由器而直接在交换设备间进行高速传输。</p>
<h2 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 参数为目的IP，子网掩码，下一跳地址</div><div class="line">[R1]ip route-static 192.168.10.10 24 192.168.2.1 </div><div class="line"># 配置缺省路由（缺省路由是静态的）</div><div class="line">[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.2.1</div></pre></td></tr></table></figure>
<h1 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><strong>动态路由</strong>（dynamic route ）</p>
<ul>
<li>路由表项是路由协议动态生成</li>
<li>根据网络结构或流量的变化，路由协议会自动调整路由信息以实现路由。</li>
</ul>
<p><strong>动态路由协议</strong></p>
<ul>
<li>按网络范围划分<br>内部网关协议－RIP，OSPF，IS-IS<br>外部网关协议－EGP，BGP</li>
<li>按寻径算法划分<br>距离矢量协议－RIP，BGP<br>链路状态协议－OSPF，IS-IS</li>
</ul>
<p><strong>RIP协议</strong><br>RIP协议是一种动态路由协议，按网络范围划分是一种内部网关协议（IGP），用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（Distance Vector Algorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。</p>
<h2 id="RIP协议原理"><a href="#RIP协议原理" class="headerlink" title="RIP协议原理"></a>RIP协议原理</h2><p>RIP路由协议的设计比较简单，在相邻的路由器之间周期性地交换整个路由表，并应用距离矢量算法来计算路由。<br><img src="http://img.blog.csdn.net/20160517103941967" alt="这里写图片描述"></p>
<ol>
<li><p>初始时刻，每台路由器上只有自身的直连路由，当启动RIP协议后，在第一个30秒内，所有路由器会向邻居路由器发送自己的完整的路由表。<br><img src="http://img.blog.csdn.net/20160517104029428" alt="这里写图片描述"></p>
</li>
<li><p>这时，路由器A和C收到了路由器B的路由表，路由器B则收到了路由器A和C的路由表，通过与自身的路由表进行比较，计算路由的跳数并更新路由表。这时路由器B已经有了全部网段的路由，而A和C分别缺4网段和1网段的路由。需要通过下一个时间周期的路由信息交换来获得。<br><img src="http://img.blog.csdn.net/20160517104525851" alt="这里写图片描述"></p>
</li>
<li><p>由于路由器B已经获得了A和C的路由信息，因此在第二个30秒，路由器A可以从B那里获得C的信息，同样C也可以从B那里获得A的信息，这样ABC都获得了全部网段的路由信息。<br><img src="http://img.blog.csdn.net/20160517104806167" alt="这里写图片描述"></p>
</li>
</ol>
<h2 id="路由环路问题"><a href="#路由环路问题" class="headerlink" title="路由环路问题"></a>路由环路问题</h2><ol>
<li><p>RIP协议在设计中没有考虑路由环路的问题，使得它存在重大缺陷。例如，当整个路由信息交换完成后，如果突然与路由器A相连的1网段链路发生故障，其S1接口为down状态，该路由项将被删除，如果此时路由器A还没有到向其他路由器通告它的路由表的时间，却收到了来自路由器B的路由通告。<br><img src="http://img.blog.csdn.net/20160517104959513" alt="这里写图片描述"></p>
</li>
<li><p>这时，路由器A会认为到1网段还有另外一条途径，它无法判断这条路由信息实际上是之前它发送给路由器B的。路由器A更新1网段路由信息，与下一跳路由器相连的接口改为S0，跳数为2.随后，路由器A会将其新的路由表通告给相邻路由器B，因为路由器B中的1网段路由是从路由器A学习的，因此路由器B会更新1网段的路由，将跳数加1.这样，路由器A、B、C的1网段的路由的跳数会不断的增加下去，直到溢出。而此时，如果有目的IP地址是1网段的报文被路由器C转发到路由器B，路由器B会将该报文转发给路由器A，而路由器A又会将此报文转发回路由器B，如此往复，直至报文的TTL字段值为0后，报文被丢弃。报文路由器A和B之间循环转圈就称为路由环路。它会很快的消耗掉连接A、B路由器的链路的带宽，对网络的危害很大。<br><img src="http://img.blog.csdn.net/20160517105257751" alt="这里写图片描述"></p>
</li>
<li><p>针对这种情况，RIP协议进行了很多的改进，例如：定义最大路由权值、触发更新、毒性逆转。但是，都没能够从根本上解决问题，使得RIP协议的使用受到了很大的限制。而究其主要原因，路由信息中没有携带始发通告路由器是主要原因。<br><img src="http://img.blog.csdn.net/20160517105351136" alt="这里写图片描述"></p>
</li>
</ol>
<h1 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>Open Shortest Path First，开放最短路由优先协议一个基于链路状态（Link status）的内部网关协议。<br><strong>核心思想</strong><br>每一台路由器将其周边的链路状态(接口直连网段、相连的路由器等信息)描述出来，发送给网络中相邻的路由器。经过一段时间的链路状态信息交互，每台路由器都保存了一个链路状态数据库，该数据库是整个网络完整的链路状态描述，最后在此基础上应用Shortest Path First算法计算路由(最短路径)。</p>
<p><strong>AS自治系统</strong><br>使用同一组选路策略的路由器的集合，OSPF就应用在AS内部，除了OSPF协议还可以使用RIP, IS-IS协议，自治系统间可以使用BGP协议。</p>
<p><strong>区域</strong><br>OSPF将一个AS分成多个区域，一个区域有着相同的拓扑结构数据库。区域ID用一个32BIT的整数来标示，可以用IP地址格式表示也可以用一个十进制整数表示。</p>
<p><strong>Router ID</strong><br>OSPF协议使用Router ID唯一表示一台路由器，采用IP地址的形式表示，可认为指定，也可能是路由器的回环地址或者最大的地址。</p>
<h2 id="OSPF报文"><a href="#OSPF报文" class="headerlink" title="OSPF报文"></a>OSPF报文</h2><p>如下图所示，OSPF协议直接用IP报文来封装自己的协议报文，其中LSA(Link Status Advertisement)为链路状态通告，路由器将把自己的链路状态以LSA报文的形式封装，作为OSPF的数据部分，与邻近的路由器分享自己的链路拓扑。<br><img src="http://img.blog.csdn.net/20160517093123045" alt="这里写图片描述"></p>
<p>上图中的OSPF报头的格式如下<br><img src="http://img.blog.csdn.net/20160517093404604" alt="这里写图片描述"><br>上图第2个字段“type”指出该OSPF报文的类型，数值从1到5分别是下列5种类型</p>
<h3 id="OSPF协议报文的5种类型"><a href="#OSPF协议报文的5种类型" class="headerlink" title="OSPF协议报文的5种类型"></a>OSPF协议报文的5种类型</h3><ul>
<li>Hello报文: 发现及维持邻居关系，选举DR(指定路由器)，BDR(备份指定路由器)。</li>
<li>DD报文: 本地LSDB的摘要</li>
<li>LSR报文: 向对端请求本端没有或对端的更新的LSA</li>
<li>LSU报文: 向对方发送其需要的LSA</li>
<li>LSAck报文: 收到LSU之后，进行确认</li>
</ul>
<p>下图为一段DD报文，与上面的报文格式对照会理解的清楚一些<br><img src="http://img.blog.csdn.net/20160517094959183" alt="这里写图片描述"></p>
<h2 id="OSPF协议的邻居状态机"><a href="#OSPF协议的邻居状态机" class="headerlink" title="OSPF协议的邻居状态机"></a>OSPF协议的邻居状态机</h2><p>OSPF协议获取网络拓扑结构的过程是自动的，它从开始到最后获得邻居所有的链路信息(建立邻接状态)需要经过许多过程，OSPF的邻居状态机显示了在这个协商过程中路由器状态的变化。</p>
<ul>
<li>Down： 邻居状态机的初始状态，是指在过去的Dead-Interval时间内没有收到对方的Hello报文 </li>
<li>Attempt： 只适用于NBMA类型的接口，处于本状态时，定期向那些手工配置的邻居发送HELLO报文 </li>
<li>Init ： 本状态表示已经收到了邻居的HELLO报文，但是该报文中列出的邻居中没有包含本Router ID（对方并没有收到我发的HELLO报文） </li>
<li>2-Way ：本状态表示双方互相收到了对端发送的HELLO报文，建立了邻居关系。在广播和NBMA类型的网络中，两个接口状态是DROther的路由器之间将停留在此状态。其他情况状态机将继续转入高级状态。</li>
<li>ExStart ： 在此状态下，路由器和它的邻居之间通过互相交换DD报文（该报文并不包含实际的内容，只包含一些标志位）来决定发送时的主/从关系。建立主/从关系主要是为了保证在后续的DD报文交换中能够有序的发送。 </li>
<li>Exchange ： 路由器将本地的LSDB用DD报文来描述，并发给邻居 </li>
<li>Loading ： 路由器发送LSR报文向邻居请求对方的LSU报文 </li>
<li>Full ： 在此状态下，邻居路由器的LSDB中所有的LSA本路由器全都有了。本路由器和邻居建立了邻接状态 </li>
</ul>
<p><img src="http://img.blog.csdn.net/20160517095403049" alt="这里写图片描述"></p>
<h3 id="OSPF报文交互过程"><a href="#OSPF报文交互过程" class="headerlink" title="OSPF报文交互过程"></a>OSPF报文交互过程</h3><p>两台路由器的交互过程及其状态变化如下：<br><img src="http://img.blog.csdn.net/20160517100455336" alt="这里写图片描述"><br>注意上图中，路由器交互过程的第2，3步DD报文主从关系协商和交换摘要信息中的seq, I，M, MS字段在DD报文(OSPF报文中的一种类型)中的字段位置如下：<br><img src="http://img.blog.csdn.net/20160517101946175" alt="这里写图片描述"></p>
<h2 id="OSPF配置"><a href="#OSPF配置" class="headerlink" title="OSPF配置"></a>OSPF配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[R1]router id 1.1.1.1 # 为该路由器配置Router ID</div><div class="line">[R1]ospf 	# 启动OSPF进程</div><div class="line">[R1]area 0 	# 创建区域0,并进入区域0视图</div><div class="line"># 指定在1.1.1.0网段上应用OSPF0.0.0.255是反掩码</div><div class="line">[R1-ospf-1-area-0.0.0.0]network 1.1.1.0 0.0.0.255</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/14/虚拟局域网VLAN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/14/虚拟局域网VLAN/" itemprop="url">虚拟局域网VLAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-14T23:23:00+08:00">
                2016-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>链路层的交换机可以隔离基于物理层的冲突域<a href="一个冲突域中的两个比特同时进行传输会发生冲突，所有的共享介质环境都是一个冲突域。两台计算机直接用网线连接，通过网桥或者集线器连接，都处在一个冲突域中。">^1</a></li>
<li>网络层的路由器可以隔离基于链路层的广播域<a href="网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为广播域。">^2</a>。</li>
<li>一些属于同一个局域网的主机，也属于同一个广播域，当其中一台主机发送广播时，广播内的所有主机都能收到广播报文。</li>
<li>设置虚拟局域网VLAN可以利用交换机将一个大的广播域划分成多个小的广播域，即多个虚拟的局域网，避免了使用路由器的高成本(不是家里那种路由器)和路由器处理报文时繁琐的过程来隔离广播域，这样就可以减少过多的广播信息所形成的广播风暴啦，增加了网络的利用率。<br><img src="http://img.blog.csdn.net/20160514220006488" alt="这里写图片描述"><br>如上图中的LAN2，连接不同交换机的主机可以也划分到同一个VLAN中</li>
</ol>
<h1 id="实现VLAN"><a href="#实现VLAN" class="headerlink" title="实现VLAN"></a>实现VLAN</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>为一个大局域网内的各网络设备的端口标记，指明他们分别属于哪个VLAN，即配置VLAN ID[^3], 同一个VLAN ID的端口间的网络就是一个虚拟局域网(也是一个广播域)。同时，为那些在这个大局域网中传播的数据帧添加标签(tag)，网络设备的端口通过将数据帧的tag和自己的VLAN ID比对，以此来确定该数据帧是否属于本VLAN。<br>802.1q标准规定在原有以太网帧格式中增加tag域，用来标示数据帧所属的VLAN ID<br><img src="http://img.blog.csdn.net/20160514213901257" alt="这里写图片描述"></p>
<h2 id="VLAN数据帧的传输"><a href="#VLAN数据帧的传输" class="headerlink" title="VLAN数据帧的传输"></a>VLAN数据帧的传输</h2><p>由于任何主机都不支持带有tag域的以太网帧，所以网络设备将VLAN以太网帧发送给交换机和主机时要区别对待。(上层的路由器不受影响)。以太网帧在VLAN交换机间传递要打上tag域，要传给主机，则要删除tag域。如果交换机收到的数据帧没有tag域，就默认它属于该端口的缺省VLAN(一个端口可以有多个VLAN, 缺省的VLAN就是原来的大局域网， H3C交换机中缺省VLAN是VLAN 1, 不打标签)。<br><img src="http://img.blog.csdn.net/20160514220812374" alt="这里写图片描述"></p>
<h2 id="VLAN端口分类"><a href="#VLAN端口分类" class="headerlink" title="VLAN端口分类"></a>VLAN端口分类</h2><ul>
<li><strong>Access端口</strong>（不打标签）：只能属于1个VLAN，从该端口出去的数据包不带TAG，一般接主机或路由器；</li>
<li><strong>trunk端口</strong>：可以属于多个VLAN，可以接收和发送带多种VLAN标签的报文，一般用于交换机之间连接的端口；</li>
<li><strong>hybrid端口</strong>：可以属于多个VLAN，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于接用户的计算机。属于Access和trunk的混合模式。</li>
</ul>
<p>Hybrid端口和trunk端口的不同之处在于hybrid端口可以允许多个VLAN的报文不打标签，而trunk端口只允许<strong>缺省VLAN</strong>的报文不打标签。因为Hybrid端口可以接主机，从主机过来或发向主机的数据帧不管属于哪个VLAN都不打标签。而trunk端口连交换机，除了默认VLAN以为的数据帧都必须打标签。</p>
<h2 id="VLAN的配置"><a href="#VLAN的配置" class="headerlink" title="VLAN的配置"></a>VLAN的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[S1]vlan 2 # 创建VLAN 2</div><div class="line"># 将e0/1-e0/5端口添加进VLAN2</div><div class="line">[S1-VLAN2]port Ethernet1/0/1 to Ethernet1/0/5 </div><div class="line">[S1-VLAN2]quit</div><div class="line"># 用同样的方法配置VLAN3</div><div class="line">[S1]vlan 3</div><div class="line">[S1-VLAN3]port Ethernet1/0/20 to Ethernet1/0/24 </div><div class="line">[S1-VLAN3]quit</div><div class="line"># 为端口配置VLAN端口类型</div><div class="line">[S1]inter Ethernet1/0/1</div><div class="line">[S1-Ethernet1/0/1]port link-type trunk # 设置该端口为trunk类型</div><div class="line"># 将该Trunk端口加入到VLAN2和VLAN3中</div><div class="line">[S1-Ethernet1/0/1]port trunk permit VLAN 2 3</div></pre></td></tr></table></figure>
<p>注意：应先配置好VLAN, 有那些端口，再去端口或者聚合端口视图中设置端口类型，如果一个端口属于多个VLAN, 还要在端口中另外设置。</p>
<ul>
<li><strong>什么情况下VLAN 要配置trunk？</strong><br>为了让不同交换机上相同的VLAN内的主机能彼此通信。如下图的VLAN2（PCA和PCC）和VLAN3(PCB和PCD).<br>当没有配置VLAN时，PCA ping PCC是没有问题的，S1收到PCA的帧后查找转发表，如果没有找到PCB就把PCA的入端口和MAC地址记下来（当有主机想联系PCA时使用)然后向除了E0/1以为的端口广播，S2也做类似的事，所以数据帧可以到达PCC。<br>而一旦设置了VLAN而没有配trunk，由于S1不能向其他端口广播了， 因此就无法ping通。因为当PCA ping PCC时, S1看了一下从PCA发过来的数据帧的tag, 不知道应该把数据帧应从哪个端口发送出去，总不能原路发回来吧，而且交换机毕竟不是路由器，不能根据IP地址和子网掩码来判断要转发的目的子网以及连接该子网的端口。而当我们为S1和S2的E0/13端口配置了trunk，且设置这2个trunk端口属于VLAN2, 那么S1和S2都将知道如何转发数据报了。<br><img src="http://img.blog.csdn.net/20160514231043816" alt="这里写图片描述"></li>
</ul>
<p>[^3]: VLAN ID的范围为0~4095（VLAN ID占12bit）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/14/端口聚合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/14/端口聚合/" itemprop="url">端口聚合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-14T17:33:00+08:00">
                2016-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>将交换机的多个物理端口捆绑在一起，成为一个逻辑端口，这一组端口可以被看做一个端口使用。这样，这个聚合的端口</p>
<ol>
<li>有了更大的带宽(总带宽等于组内各端口带宽之和)</li>
<li>增加了端口冗余(只要剩一个没坏就能通信)</li>
<li>可以将负载均衡到组内的各个端口上。</li>
</ol>
<p>两个交换机间的链路两端都使用端口聚合，他们之间的链路就成为了聚合链路，同样具备上述3个特点，即更多带宽，更多冗余，负载均衡。</p>
<p><img src="http://img.blog.csdn.net/20160514173302071" alt="S1和S2间的聚合链路"></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>关键：帧分发器、帧接收器<br>当交换机S1通过聚合链路向交换机S2发送数据时，从上层协议来的数据帧在链路层排队，由帧分发器按照一定规则将同样是发送给交换机S2的数据帧分发到不同的端口发送队列中去，交由各个端口分开发送。这里需要注意，帧分发器不会拆分数据帧，而且为了保证有序传输会将同一会话的数据帧分配到同一端口发送。当数据到达对端后，交换机S2的帧接收器将接受到的数据帧按接受顺序上交给上层协议。为什么可以直接按接收顺序上交？因为在交换机S1那里的帧发送器保证了数据帧的顺序。</p>
<p>注意：如果两个交换机之间有多条链路，而没有做端口聚合也没用使用生成树协议，将会产生广播风暴<a href="2个交换机间有多个链路，形成网络回路，是产生广播风暴的原因之一。当主机发送广播（如ARP请求）时，交换机S1转发该广播，交换机S2接收到该广播，由于没有找到目的主机，又继续广播。这时S1又收到了广播，然后他俩不断广播来，广播去，占尽网络带宽，形成广播风暴，交换机端口上的灯会不断闪烁。">^1</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在没有使用生成树协议的情况下(undo stp enable)<br>这里我需要配置两路由器间的聚合链路，那么就需要先在俩交换机中配置端口聚合。（为了配置端口聚合，我不是道是不是还需要将每个端口的配置成一样的双工模式和速率，以前是需要的，先这么着吧，怕考试时出错）这里我需要聚合的端口包括端口e0/1和e0/2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[S1]interface Bridge-Aggregation 1 # 创建二层端口聚合组1</div><div class="line">[S1-Bridge-Aggregation1]link-aggregation mode dynamic # 设置动态聚合模式                                             </div><div class="line">[S1-Bridge-Aggregation1]inter Ethernet1/0/1</div><div class="line">[S1-Ethernet1/0/1]duplex full # 该端口全双工</div><div class="line">[S1-Ethernet1/0/1]speed 100 # 该端口速率</div><div class="line">[S1-Ethernet1/0/1]port link-mode bridge # 使端口工作在二层模式</div><div class="line">[S1-Ethernet1/0/1]port link-aggregation group 1 # 将该端口加入聚合组1</div><div class="line"># 下面是到e0/2再设置一遍</div><div class="line">[S1-Ethernet1/0/1]inter Ethernet1/0/2</div><div class="line">[S1-Ethernet1/0/2]duplex full</div><div class="line">[S1-Ethernet1/0/2]speed 100</div><div class="line">[S1-Ethernet1/0/2]port link-mode bridge</div><div class="line">[S1-Ethernet1/0/2]port link-aggregation group 1</div><div class="line">[S1-Ethernet1/0/2]quit</div><div class="line"># 配置全局聚合负载分担模式为按报文的目的MAC地址和源MAC地址实现聚合负载分担</div><div class="line">[S1]link-aggregation load-sharing mode destination-mac source-mac</div></pre></td></tr></table></figure></p>
<p>别忘了，在聚合链路的<strong>另一边的交换机</strong>也需要进行相同的配置。<br>如果还要配置vlan的truck/access/hybrid端口, 可以到这个聚合组中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[S1]interface Bridge-Aggregation 1</div><div class="line">[S1-Bridge-Aggregation1] port access vlan 2</div><div class="line">[S1-Bridge-Aggregation1] quit</div></pre></td></tr></table></figure></p>
<p>最好在前面创建聚合组1的时候就把vlan端口类型设置上。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/13/NAT地址转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/13/NAT地址转换/" itemprop="url">NAT地址转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-13T22:34:00+08:00">
                2016-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>为了解决IPv4地址短缺的问题，通过内网到外网出口的NAT路由器(有NAT功能的路由器), 将许多的内网IP地址映射为少数的几个外网IP地址，使得内网只有私有地址的计算机也能上网。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li>内网PC向外网PC发送请求，途径某出口NAT路由器</li>
<li>该路由器先查看它自己是公网地址池，取出一条可用的公网地址，将“转换前的源地址和源端口号、转换后的源地址和源端口号”插入地址转换表中，便于外网PC响应时可以原路返回找到那台内网的PC</li>
<li>NAT路由器用新的源地址和源端口号，而目的地址和端口号不变，重新封装报文，再将报文发送出去</li>
<li>外网PC收到报文后发回应答报文，源地址和源端口号是刚才那条请求报文的目的地址和端口号，目的地址和端口号是NAT路由器封装后的源地址/端口号</li>
<li>NAT收到应答报文，再根据应答报文的目的地址和端口查找地址转换表，再将报文的目的地址和端口改过来，才发送到内网。</li>
<li>由于应答报文中的目的地址是内网的地址，因此内网中的那台PC能顺利收到应答报文<br><img src="http://img.blog.csdn.net/20160513214557643" alt="这里写图片描述"></li>
</ol>
<h1 id="H3C设置指令"><a href="#H3C设置指令" class="headerlink" title="H3C设置指令"></a>H3C设置指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 建立编号为2001的IPV4基本访问控制列表(Access Control Lists)[R1]acl basic 2001</div><div class="line"># 建立允许源地址为10.0.0.*(0.0.0.255为反掩码)的转换规则0</div><div class="line">[R1-acl-2001]rule 0 permit source 10.0.0.0 0.0.0.255 </div><div class="line"># 建立拒绝其他源地址的转换规则1</div><div class="line">[R1-acl-2001]rule 1 deny source any</div><div class="line"># 配置地址池1</div><div class="line">[R1]nat address-group 1</div><div class="line"># 为地址池1添加公网地址192.168.5.5-9</div><div class="line">[R1-address-group-1]address 192.168.5.5 192.168.5.9 </div><div class="line"># 进入e0/1接口</div><div class="line">[R1]inter GigabitEthernet 0/1</div><div class="line"># 配置出接口e0/1使用访问控制表2001和地址池1</div><div class="line">[R1-GigabitEthernet0/1]nat outbound 2001 address-group 1</div><div class="line">[R1-GigabitEthernet0/1]quit</div><div class="line"># 配置默认网关，参数分别是目的地址，子网掩码，下一条地址，</div><div class="line"># 如果目的地址和子网掩码都是0表示这是一条默认路由，</div><div class="line"># 下一条指向网关</div><div class="line">[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.5.1</div></pre></td></tr></table></figure>
<p>ACL编号的取值范围及其代表的ACL类型如下：<br>100～199：表示WLAN ACL；<br>2000～2999：表示IPv4基本ACL；<br>3000～3999：表示IPv4高级ACL；<br>4000～4999：表示二层ACL。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/06/pthread中如何计时/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/06/pthread中如何计时/" itemprop="url">pthread中如何计时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-06T15:01:00+08:00">
                2016-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用pthread编写的多线程程序，若是用clock_t结构体和clock()函数计时，多线程程序的运行时间会偏大，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;time.h&gt;</div><div class="line">clock_t begin, end;</div><div class="line">begin = clock();</div><div class="line">// pthread多线程代码</div><div class="line">end = clock();</div><div class="line">printf(&quot;%f秒\n&quot;,  (double)(t1 - t0) / CLOCKS_PER_SEC);</div></pre></td></tr></table></figure></p>
<p>这是因为clock()记录了所有CPU的时钟滴答数[^footer1], 求出的自然是所有Cores的使用时间之和。要计算实际并行计算的真实时间，应该使用lrt，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;time.h&gt;</div><div class="line">struct timespec begin, end;</div><div class="line">double timediff;</div><div class="line">clock_gettime(CLOCK_MONOTONIC, &amp;begin);</div><div class="line">// pthread多线程代码</div><div class="line">clock_gettime(CLOCK_MONOTONIC, &amp;end);</div><div class="line">timediff = end.tv_sec - begin.tv_sec + (end.tv_nsec - begin.tv_nsec) / 1000000000.0;</div><div class="line">printf(&quot;排序时间为%f秒\n&quot;,  timediff);</div></pre></td></tr></table></figure></p>
<p>其中的timespec的结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct timespec &#123;</div><div class="line">    time_t tv_sec;     // 秒    </div><div class="line">    long int tv_nsec;  // 纳秒   </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>编译时需加入参数-lrt, 如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@slave02 yy]# g++ test.cpp -lrt -o test -lpthread</div></pre></td></tr></table></figure></p>
<p>[^footer1]: 时钟滴答数（clock tick），从进程启动开始计时，因此这是相对时间。每秒钟包含CLOCKS_PER_SEC（time.h中定义的常量，一般为1000）个时钟滴答。时钟滴答数用数据类型clock_t表示。clock_t类型一般是32位整数类型。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/23/在vs2008中配置OpenMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/23/在vs2008中配置OpenMP/" itemprop="url">在vs2008中配置OpenMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-23T11:37:00+08:00">
                2016-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在vs2008上编译OpenMP"><a href="#在vs2008上编译OpenMP" class="headerlink" title="在vs2008上编译OpenMP"></a>在vs2008上编译OpenMP</h1><ol>
<li>试了好多方法，感觉直接在vs2008上写最简单，右键点击解决方案下面的项目名，在弹出的右键菜单选择最后一个“属性”。<br><img src="http://img.blog.csdn.net/20160323112356122" alt="这里写图片描述"></li>
<li>依次点击 配置属性 =》C/C++ =》语言，把右侧的OpenMP支持一栏的否改为是。这样你的OpenMP程序就可以编译了。<br><img src="http://img.blog.csdn.net/20160323112557920" alt="这里写图片描述"></li>
<li>如果运行程序时报错，找不到vcomp90.dll或者vcomp90d.dll，那么就到c:\windows\winsxs\目录下搜索vcomp90，并把vcomp90.dll和vcomp90d.dll这两个文件复制到你的项目根目录处，即有.vcproj的目录，而不是最外层的目录。这两个文件也可以到我的网盘下载<br><a href="http://pan.baidu.com/s/1skpWeKH" target="_blank" rel="external">点击进入网盘下载</a><br><img src="http://img.blog.csdn.net/20160323113217567" alt="这里写图片描述"></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/7233064.jpg"
               alt="Yiyang Peng" />
          <p class="site-author-name" itemprop="name">Yiyang Peng</p>
           
              <p class="site-description motion-element" itemprop="description">Try try try Never mind</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yiyang186" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/peng-yiyang-88" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yiyang Peng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
